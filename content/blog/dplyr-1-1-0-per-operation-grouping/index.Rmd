---
output: hugodown::hugo_document
slug: dplyr-1-1-0-per-operation-grouping
title: "dplyr 1.1.0: Per-operation grouping"
date: 2023-02-01
author: Davis Vaughan
description: >
    dplyr now supports an experimental per-operation grouping syntax through a new argument
    named `.by`. This serves as an alternative to `group_by()`.
photo:
  url: https://www.pexels.com/photo/fruit-stand-375897/
  author: Clem Onojeghuo
categories: [package] 
tags: [dplyr]
editor_options: 
  chunk_output_type: console
---

Today we are going to look at one of the major new features in [dplyr 1.1.0](https://dplyr.tidyverse.org/news/index.html#dplyr-110), per-operation grouping with `.by`/`by`.
This is an exciting alternative to `group_by()` that only applies grouping within a single dplyr verb.

You can install it from CRAN with:

```{r, eval = FALSE}
install.packages("dplyr")
```

```{r setup, message=FALSE, warning=FALSE}
library(dplyr)
```

## Persistent grouping with `group_by()`

In dplyr, grouping radically affects the computation of the verb that you use it with.
Since the very beginning of dplyr, you've been able to perform grouped operations with `group_by()`.
This grouping is *persistent*, meaning that it typically sticks around in some form for more than one operation.
For example, this `transactions` dataset tracks revenue brought in from various transactions across multiple companies.
If we wanted to add a column for the total yearly revenue per company, we might do:

```{r}
transactions <- tibble(
  company = c("A", "A", "A", "B", "B", "B"),
  year = c(2019, 2019, 2020, 2021, 2023, 2023),
  revenue = c(20, 50, 4, 10, 12, 18)
)

transactions
```

```{r}
transactions |>
  group_by(company, year) |>
  mutate(total = sum(revenue))
```

Notice that the result is still grouped by both `company` and `year`.
This is sometimes useful if you need to compute additional grouped results (with the exact same grouping columns) in a follow up operation, but often many people follow this `mutate()` with an `ungroup()`.

Similarly, if we just wanted the total revenue in a summary table, we would have used `summarise()`, which peels off 1 layer of grouping by default:

```{r}
transactions |>
  group_by(company, year) |>
  summarise(total = sum(revenue))
```

## Per-operation grouping with `.by`/`by`

In dplyr 1.1.0, we've introduced an alternative to `group_by()` known as `.by` that allow for *per-operation* grouping instead:

```{r}
transactions |>
  mutate(total = sum(revenue), .by = c(company, year))

transactions |>
  summarise(total = sum(revenue), .by = c(company, year))
```

There are a few things about `.by` worth noting:

-   The result is always ungrouped.
    With `.by`, you never need to remember to call `ungroup()`.

-   We use tidy-select to group by multiple columns.

One of the things we like about `.by` is that it allows you to place the grouping specification alongside the code that actually uses it, rather than in a separate `group_by()` line.
This idea was actually inspired by data.table's grouping syntax, which looks like:

```{r, eval=FALSE}
transactions[, .(total = sum(revenue)), by = .(company, year)]
```

### `.by` or `by`?

As you begin to use per-operation grouping in dplyr, you'll likely notice that some verbs use `.by` and others use `by`, for example:

```{r}
transactions |>
  slice_max(revenue, n = 2, by = company)
```

This is purely a technical difference resulting from the fact that some verbs consistently use a `.` prefix for their arguments, and others don't.
Most dplyr verbs use `.by`, and we've tried to ensure that the cases that are most likely to result in typos instead generate an informative error:

```{r, error=TRUE}
# Uses `by` to be consistent with `n` and `prop`
transactions |>
  slice_max(revenue, n = 2, .by = company)

# Uses `.by` to be consistent with `.preserve`
transactions |>
  slice(revenue, by = company)
```

### Translating from `group_by()`

You shouldn't feel pressured to translate existing code using `group_by()` to use `.by` instead.
`group_by()` definitely won't ever disappear, and is not currently being superseded.

That said, if you do want to start using `.by`, there are a few differences from `group_by()` to be aware of.

-   `.by` always returns an ungrouped data frame.
    This is one of the main reasons to use `.by`, but is worth keeping in mind if you have existing code that takes advantage of the persistent grouping from `group_by()`.

-   `.by` uses tidy-selection.
    `group_by()`, on the other hand, works more like `mutate()` in that it allows you to create grouping columns on the fly, i.e. `df |> group_by(month = floor_date(date, "month"))`.
    With `.by`, you must create your grouping columns ahead of time.
    An added benefit of `.by`'s usage of tidy-selection is that you can supply an external character vector of grouping variables using `.by = all_of(groups_vec)`.

-   `.by` doesn't sort grouping keys.
    `group_by()` always sorts keys in ascending order, which affects the results of verbs like `summarise()`.

The last point might seem strange, but consider what would happen if we preferred our transactions data in order by descending year.

```{r}
transactions2 <- transactions |>
  arrange(company, desc(year))

transactions2
```

```{r}
# Note that `group_by()` re-ordered
transactions2 |>
  group_by(company, year) |>
  summarise(total = sum(revenue), .groups = "drop")

# But `.by` used whatever order was already there
transactions2 |>
  summarise(total = sum(revenue), .by = c(company, year))
```

Notice that `.by` doesn't re-sort the grouping keys.
Instead, the previous call to `arrange()` is "respected" in the summary (this is also useful in combination with the new `.locale` argument to `arrange()`).

## `nest(.by = )`

```{r}
library(tidyr)
```

The idea behind `.by` turns out to be useful in contexts outside of dplyr.
In [tidyr 1.3.0](https://www.tidyverse.org/blog/2023/01/tidyr-1-3-0/#nestby), `nest()` gained a `.by` argument, allowing you to specify the columns you want to nest *by* rather than the columns that appear in the nested results, which often makes for more natural calls to `nest()`.

```{r}
# Specify what to nest by
transactions |>
  nest(.by = company)

# Specify what to nest
transactions |>
  nest(data = -company)

# Specify both, allowing you to drop `year` along the way
transactions |>
  nest(data = revenue, .by = company)
```

We currently have 3 different nesting variants in the tidyverse: `tidyr::nest()`, `dplyr::group_nest()`, and `dplyr::nest_by()`.
Because the tidyr variant is now the most flexible of all of these, and because `unnest()` also lives in tidyr, we are likely to deprecate the two experimental dplyr options in the future.
