---
output: hugodown::hugo_document

slug: yaml12-0-1-0
title: yaml12 for R and Python
date: 2025-12-12
author: Tomasz Kalinowski
description: >
    We’re pleased to announce two new YAML 1.2 packages: `yaml12` for R and
    `py-yaml12` for Python. Both are implemented in Rust and designed for
    fast, predictable YAML 1.2 parsing, with safe opt-in tag handling and document stream support.

photo:
  url: https://unsplash.com/photos/green-plant-on-brown-clay-pot-PAEwrnasOvY
  author: Devin H

# one of: "deep-dive", "learn", "package", "programming", "roundup", or "other"
categories: [package]
tags: [yaml, r, python, rust]
---

<!--
TODO:
* [x] Look over / edit the post's title in the yaml
* [x] Edit (or delete) the description; note this appears in the Twitter card
* [x] Pick category and tags (see existing with `hugodown::tidy_show_meta()`)
* [x] Find photo & update yaml metadata
* [x] Create `thumbnail-sq.jpg`; height and width should be equal
* [x] Create `thumbnail-wd.jpg`; width should be >5x height
* [x] `hugodown::use_tidy_thumbnails()`
* [x] Add intro sentence, e.g. the standard tagline for the package
* [ ] `usethis::use_tidy_thanks()` (optional)
-->

Today we’re announcing two new packages for parsing and emitting YAML 1.2:
[`yaml12`](https://posit-dev.github.io/r-yaml12/) for R and
[`py-yaml12`](https://posit-dev.github.io/py-yaml12/) for Python.

In Python, the package is published on PyPI as `py-yaml12`, but you import it
as `yaml12`.

Both packages are implemented in Rust (built on the excellent
[`saphyr`](https://github.com/saphyr-rs/saphyr) crate). They share the same
design goals: predictable YAML 1.2 typing, explicit control over tag
interpretation via handlers, and clean round-tripping of unhandled tags.

## Install

Install the R package from CRAN:

```{r, eval = FALSE}
install.packages("yaml12")
```

Install the Python package from PyPI:

```bash
pip install py-yaml12
```

## Quick start (R)

```{r quick_start_r}
library(yaml12)

yaml <- "
title: A modern YAML parser and emitter written in Rust
properties: [fast, correct, safe, simple]
"

doc <- parse_yaml(yaml)
str(doc)
```

Round-trip back to YAML:

```{r round_trip_r}
obj <- list(
  seq = 1:2,
  map = list(key = "value"),
  tagged = structure("1 + 1", yaml_tag = "!expr")
)
write_yaml(obj)

identical(obj, parse_yaml(format_yaml(obj)))
```

## Quick start (Python)
```{r, include=FALSE}
#reticulate::py_require("git+https://github.com/posit-dev/py-yaml12")
reticulate::py_require("py-yaml12@/Users/tomasz/github/posit-dev/py-yaml12")
```

```{python quick_start_python}
# Install from PyPI:
#   python -m pip install py-yaml12
from yaml12 import parse_yaml, format_yaml, Yaml

yaml_text = """
title: A modern YAML parser and emitter written in Rust
properties: [fast, correct, safe, simple]
"""

doc = parse_yaml(yaml_text)

assert doc == {
  "title": "A modern YAML parser and emitter written in Rust",
  "properties": ["fast", "correct", "safe", "simple"]
}

assert doc == parse_yaml(format_yaml(doc))

# Tagged values
tagged = parse_yaml("!expr 1 + 1")
assert tagged == Yaml(value="1 + 1", tag="!expr")
```

## Why YAML 1.2?

YAML 1.2 tightened up a number of ambiguous implicit conversions. In
particular, plain scalars like `on`/`off`/`yes`/`no`/`y`/`n` are strings in the
1.2 core schema, and YAML 1.2 removed sexagesimal parsing (so values like `1:2` are
not treated as numbers).

YAML 1.2 also removed `!!timestamp`, `!!binary`, and `!!omap` from the set of core
types, which further reduces implicit coercions (for example, getting a
date/time object when you expected a string). If you want to interpret those
values, you can do so explicitly via tags and handlers.

That makes YAML a better default for configuration files, front matter, and
data interchange: fewer surprises and fewer “why did this become a boolean?”
moments (or “why did this become a date?”).

## Highlights

### A consistent API in R and Python

The two packages intentionally share the same high-level functions:

- `parse_yaml()`: Parse YAML from a string
- `read_yaml()`: Parse YAML from a file
- `format_yaml()`: Format values as YAML (to a string)
- `write_yaml()`: Write YAML to a file (or stdout)

### Tags and handlers (opt-in, meaning, safe defaults)

Tags are preserved by default:

- In R, tags are kept in a `yaml_tag` attribute.
- In Python, tags are kept by wrapping values in a `Yaml` object.

Handlers let you opt into custom behavior for tags (including tags on mapping
keys) while keeping parsing as a data-only operation by default.

R example:

```{r tags_and_handlers_r}
dput(yaml12::parse_yaml("!upper foo"))

handlers <- list("!upper" = toupper)
yaml12::parse_yaml("!upper foo", handlers = handlers)
```

Python example:

```{python tags_and_handlers_python}
from yaml12 import parse_yaml

handlers = {"!upper": str.upper}
parse_yaml("!upper foo", handlers=handlers)
```

### Simplification and missing values (R)

In R, `parse_yaml()` can simplify homogeneous sequences to vectors. When it
does, YAML `null` becomes the appropriate `NA` type:

```{r simplify_r}
yaml12::parse_yaml("[1, 2, 3, null]")

str(yaml12::parse_yaml("[1, 2, 3, null]", simplify = FALSE))
```

### Non-string mapping keys

YAML allows mapping keys that aren’t plain strings (numbers, booleans, tagged
scalars, even sequences and mappings). Both packages preserve these safely:

- In R, you’ll get a regular named list plus a `yaml_keys` attribute when
  needed.
- In Python, unhashable keys (like lists/dicts) are wrapped in `Yaml` so they
  can still be used as `dict` keys and round-trip correctly.

R example:

```{r non_string_keys_r}
dput(yaml12::parse_yaml("{a: b}: c"))
```

Python example:

```{python non_string_keys_python}
from yaml12 import parse_yaml, Yaml

doc = parse_yaml("{a: b}: c")
assert doc == {Yaml({'a': 'b'}): 'c'}
```

### Mapping order is preserved

YAML mappings are ordered. `yaml12` preserves mapping/dictionary order when
parsing and formatting, so the order you see in a YAML file (or emit) round-trips
in both R and Python.

### Document streams and front matter

Both packages support multi-document YAML streams with `multi = TRUE`.
When `multi = FALSE` (the default), parsing stops after the first document,
which is handy for extracting YAML front matter from text that continues
with non-YAML content.

Example:

```{r document_streams_r}
yaml <- "
---
title: Extracting YAML frontmatter
---
This is technically now the second document in a YAML stream
"
str(parse_yaml(yaml))
str(parse_yaml(yaml, multi = TRUE))
```

### Performance and safety notes

`yaml12` is implemented in Rust and written with performance and safety in
mind. It avoids unnecessary allocations, copies, and extra traversals where
possible. In Python, `py-yaml12` (imported as `yaml12`) also releases the GIL
for large parses and serializations.

Tags are preserved by default, and interpreting them (including any kind of
evaluation) is always an explicit opt-in via handlers. Plain scalars follow
the YAML 1.2 core schema rules for predictable typing.

In Python, `py-yaml12` ships prebuilt wheels for common platforms. If you do
need to build from source, you’ll need a Rust toolchain. In R, `yaml12` is
available from CRAN (including binaries on common platforms).

## Wrapping up

If you work with YAML as a data format for configuration, front matter, or data
interchange, we hope `yaml12` (R) and `py-yaml12` (Python) help you parse
and emit YAML 1.2 predictably. If you run into YAML that doesn’t behave as
expected, we’d love to hear about it in the issue trackers:
[r-yaml12](https://github.com/posit-dev/r-yaml12/issues) and
[py-yaml12](https://github.com/posit-dev/py-yaml12/issues).

## Learn more

- R package docs: https://posit-dev.github.io/r-yaml12/
- R package on CRAN: https://cran.r-project.org/package=yaml12
- Python package docs: https://posit-dev.github.io/py-yaml12/
- Python package on PyPI: https://pypi.org/project/py-yaml12/

## Acknowledgements

Both packages build on the fantastic work in the YAML ecosystem,
especially the `saphyr` Rust crate and the
[yaml-test-suite](https://github.com/yaml/yaml-test-suite).
