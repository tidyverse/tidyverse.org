---
output: hugodown::hugo_document

slug: purrr-1-0-0
title: purrr 1.0.0
date: 2022-11-10
author: Hadley Wickham
description: >
    purrr 1.0.0 brings a basket of updates to purrr. We deprecated a number of
    seldom used functions to hone in on the core purpose of purrr while 
    implemented a swath of new features including progress bars, improved 
    error reporting, and much much more!

photo:
  url: https://unsplash.com/photos/YCPkW_r_6uA
  author: Jari Hyt√∂nen

# one of: "deep-dive", "learn", "package", "programming", "roundup", or "other"
categories: [package] 
tags: [purrr]
---

```{=html}
<!--
TODO:
* [x] Look over / edit the post's title in the yaml
* [x] Edit (or delete) the description; note this appears in the Twitter card
* [x] Pick category and tags (see existing with `hugodown::tidy_show_meta()`)
* [x] Find photo & update yaml metadata
* [x] Create `thumbnail-sq.jpg`; height and width should be equal
* [x] Create `thumbnail-wd.jpg`; width should be >5x height
* [x] `hugodown::use_tidy_thumbnails()`
* [x] Add intro sentence, e.g. the standard tagline for the package
* [ ] `usethis::use_tidy_thanks()`
-->
```
```{r}
#| include: false
asciicast::init_knitr_engine()
```

We're happy to announce the release of [purrr](http://purrr.tidyverse.org/) 1.0.0!
purrr enhances R's functional programming toolkit by providing a complete and consistent set of tools for working with functions and vectors.

You can install it from CRAN with:

```{r, eval = FALSE}
install.packages("purrr")
```

purrr is 7 years old, but it's finally made it to 1.0.0!
This was an opportunity to really refine the core purrrpose of purrr, making it more purrrsimonious by moving a number of functions to purrrgatory.
Hopefully these changes are not cat-istrophic.

In this post, we'll start with an overview of the breaking changes in this release.
We'll then briefly review some documentation changes, before moving on to the big new stuff: refinements to the map functions (including progress bars!), new `keep_at()` and `discard_at()`, and changes to flattening and simplification.

One small note: in alignment our 2021 policy [purrr has been re-licensed](https://www.tidyverse.org/blog/2021/12/relicensing-packages/) with the MIT license.

You can see a full list of changes in the [release notes](%7B%20github_release%20%7D)

```{r setup}
library(purrr)
```

## Breaking changes

First the bad stuff: we've made some changes to the way purrr operates.
We've been a bit more aggressive than usual here because A 1.0.0 release is an opportunity to make some bigger changes to the package to ensure it's on firm footing for the next 10 years.
Nevertheless, we don't anticipate too many impacts on user code.
As part of our new policy, I made pull requests to all [CRAN packages that broke](https://github.com/tidyverse/purrr/issues/969) (except for the 1 that wasn't on GitHub).
Out of \~1,400 dependencies only \~40 had problems.
I've found making these PRs very empathy building and I'm getting much faster at parachuting into a random package that I have no idea what it does and fixing the problems.
This act also gave me confidence that while we're deprecating quite a few functions and changing a few special cases, it shouldn't affect too much code in the wild.

### pluck and zero-length vectors

Previously, `pluck()` would replace 0-length vectors with the value of `default`.
Now only `NULL` and absent elements will be replaced with `default`:

```{r}
x <- list(y = list(a = character(), b = NULL))
x |> pluck("y", "a", .default = NA)
x |> pluck("y", "b", .default = NA)
x |> pluck("y", "c", .default = NA)
```

This also influences the map family because using an integer vector, character vector, or list automatically calls `pluck()`:

```{r}
x <- list(list(1), list(), list(NULL), list(character()))
x |> map(1, .default = 0) |> str()
```

We made this change because it makes purrr more consistent with the rest of the tidyverse which distinguishes zero-length vectors from `NULL`s, and it looks like it was a bug in the original implementation of the function.

### Tidyverse consistency

We've tweak the map family of functions to be more consistent with general tidyverse recycling and coercion rules, as implemented by the vctrs package.
`map_lgl()`, `map_int()`, `map_int()`, and `map_dbl()` now follow the same coercion rules as vctrs.
This means that:

-   `map_chr(TRUE, identity)`, `map_chr(0L, identity)`, and `map_chr(1L, identity)` are deprecated because we believe that converting a logical/integer/double to a character vector is potentially dangerous and should require an explicit coercion.

    ```{r}
    # previously you could write
    map_chr(1:4, \(x) x + 1)

    # now you need something like this:
    map_chr(1:4, \(x) as.character(x + 1))
    ```

-   `map_int()` requires that the numeric results be close to integers, rather than silently truncating to integers.
    Compare these two examples:

    ```{r}
    #| error: true
    map_int(1:3, \(x) x / 2)

    map_int(1:3, \(x) x * 2)
    ```

`map2()`, `modify2()`, and `pmap()` use tidyverse recycling rules where vectors of length 1 are recycled to any size but all others must have the same length.
This has two major changes:

-   Previously, the presence of a zero-length input generated a zero-length output. Now its recycled using the same rules:

    ```{r}
    #| error: true

    map2(1:2, character(), paste)

    # Works because length-1 vector gets recycled to length-0
    map2(1, character(), paste)
    ```

-   And now must explicitly recycle vectors that aren't length 1:

    ```{r}
    #| error: true

    map2_int(1:4, c(10, 20), `+`)

    map2_int(1:4, rep(c(10, 20), 2), `+`)
    ```

### Assigning `NULL`

There are a number of purrr functions that allow you to modify a list in someway: `pluck<-`, `assign_in()`, `modify()`, `modify2()`, `modify_if()`, `modify_if()`, and `list_modify()`.
Previously these functions had inconsistent behaviour when you attempted to modify an element with `NULL`: some functions would delete that element, and some would set it to `NULL`.
That inconsistency arose because base R handles `NULL` in different ways depending on whether or not use you `$`/`[[` or `[`:

```{r}
x1 <- x2 <- x3 <- list(a = 1, b = 2)

x1$a <- NULL
str(x1)

x2["a"] <- list(NULL)
str(x2)
```

That difference accidentally causes different purrr functions to handle `NULL` differently.
Now all list modifying functions will create an element containing `NULL`:

```{r}
x3 |> 
  list_modify(a = NULL) |> 
  str()

x3 |> 
  modify_at("b", \(x) NULL) |> 
  str()
```

If you want to delete the element, you'll need to use the special `zap()` sentinel:

```{r}
x3 |> 
  list_modify(a = zap()) |> 
  str()
```

`zap()` does not work in `modify()` and friends because they are designed to always return the same top-level structure as the input.

### Core purpose refinements

As well as changing the behaviour of some functions, we've deprecated a number of functions have been deprecated to keep purrr focused on its core purpose: facilitating functional programming in R.
Deprecating these functions makes purrr easier to maintain because it reduces the surface area for bugs and issues, and it makes purrr easier to learn because there's a clearer common thread that ties together all functions.

-   `cross()` and all its variants have been deprecated because they're slow and buggy, and a better approach already exists in `tidyr::expand_grid()`.

-   `update_list()`, `rerun()`, and the use of tidyselect with `map_at()` and friends have been deprecated because we no longer believe that non-standard evaluation is a good fit for purrr.

-   The `lift_*` family of functions has been deprecated because they rely on a style of function manipulation that is uncommon in R.

-   `prepend()`, `rdunif()`, `rbernoulli()`, `when()`, and `list_along()` have all been deprecated because they don't align with the core purpose of purrr.

-   `splice()` was deprecated because we no longer believe that automatic splicing makes for good UI and there are other ways to achieve the same result.

Consult the documentation for the alternatives that we now recommend.

Deprecation means that the functions will continue to work, you'll get warned once every 8 hours if you use them.
In several years time, we'll release an update which causes the warnings to occur on every time you use them, and a few years after that they'll transformed to throwing errors.

## Documentation

As you've seen in the code above, we are gradually moving to the base pipe (`|>`) instead of magrittr's pipe (`|>`) and R's anonymous function short hand (`\(x) x + 1`) instead of formula syntax (`~ .x + 1`).
We believe that it's better to use the new base equivalents because they work everywhere: the base pipe doesn't requite that you load magrittr and the new function shorthand works everywhere, not just in purrr functions.
Additionally, being able to specify the argument name for the anonymous function can often lead to clearer code.

```{r}
# Previously we wrote
1:10 %>%
  map(~ rnorm(10, .x)) %>%
  map_dbl(mean)

# Now we recommend
1:10 |>
  map(\(mu) rnorm(10, mu)) |>
  map_dbl(mean) 
```

Note, that due to the [tidyverse R dependency policy](https://www.tidyverse.org/blog/2019/04/r-version-support/), purrr works in R 3.5, 3.6, 4.0, 4.1, and 4.2, but the base pipe and anonymous function syntax are only available in R 4.0 and later.
To allow purrr to continue to pass `R CMD check`, the examples are automatically disabled in older versions of R.

## Mapping

The map functions have received a major overhaul with three big new features:

-   Progress bar.
-   Better errors.
-   New `map_vec()`.

These are described in the following sections.

### Progress bars

```{asciicast}
#| include: false
library(purrr)
options(cli.progress_show_after = 0)
options(cli.progress_clear = FALSE)
```

The map family of function can now produce a progress bar.
This is very useful for long running jobs:

```{asciicast progress}
#| asciicast_at: "all"
#| cache: true
x <- map(1:100, \(x) Sys.sleep(0.1), .progress = TRUE)
```

(For interactive use, the progress bar uses some simple heuristics so that it doesn't show up for very simple jobs.)

In most cases, we expect that `.progress = TRUE` will give you a decent progress bar.
But if you're wrapping the `map()` in a function, you might want to set it to a string that 's used to identify the progress bar:

```{asciicast named-progress}
#| asciicast_at: "all"
#| cache: true
walk(1:100, \(i) Sys.sleep(0.1), .progress = "Saving plots")
```

### Better errors

If there's an error in the function you're mapping, `map()` and friends now tell you which element caused the problem:

```{r}
#| error: true
x <- sample(1:500)
x |> map(\(x) if (x == 1) stop("Error!") else 10)
```

We hope that this makes your debugging life just a little bit easier!
(Don't forget about `safely()` and `possibly()` if you expect failures and want to either ignore or capture them.)

We have also generally reviewed the error messages throughout purrr in order to make them more actionable.
If you hit a confusing error message, please let us know!

### New `map_vec()`

We've added `map_vec()` (along with `map2_vec()`, and `pmap_vec()`) to handle more types of vector.
`map_vec()` extend `map_lgl()`, `map_int()`, `map_dbl()`, and `map_chr()` to make it easier to work with dates, factors, date-times and more:

```{r}
1:3 |> map_vec(\(i) factor(letters[i]))
1:3 |> map_vec(\(i) factor(letters[i], levels = letters[4:1]))

1:3 |> map_vec(\(i) as.Date(ISOdate(i + 2022, 10, 5)))
1:3 |> map_vec(\(i) ISOdate(i + 2022, 10, 5))
```

`map_vec()` exists somewhat in the middle of base R's `sapply()` and `vapply()`.
Unlike `sapply()` it will always return a simpler vector, erroring if there's no common type.

```{r}
#| error: true
list("a", 1) |> map_vec(identity)
```

If you want to require a certain type of output, supply `.ptype`, making `map_vec()` behaviour more like `vapply()` (but supporting more types).
`ptype` is short for prototype, and should be a vector that exemplifies the type of output you expect.

```{r}
#| error: true

x <- list("a", "b") 
x |> map_vec(identity, .ptype = character())

# map_vec() will error if the result isn't compatible with ptye
x <- list(1, 2) 
x |> map_vec(identity, .ptype = character())
```

We don't expect you to know or memorise the [rules that vctrs uses for coercion](https://vctrs.r-lib.org/reference/faq-compatibility-types.html) our hope is that as we slowly ensure that every tidyverse function follows the same rules that these will be become second nature.

## `keep_at()` and `discard_at()`

purrr has gained a new pair of functions `keep_at()` and `discard_at()`: they work similarly to `keep()` and `discard()` but operate on names rather than values:

```{r}
x <- list(a = 1, b = 2, c = 3, D = 4, E = 5)

x |> 
  keep_at(c("a", "b", "c")) |> 
  str()

x |> 
  discard_at(c("a", "b", "c")) |> 
  str()
```

Alternatively, you can supply a function that is called with the names of the elements and should return a logical vector describing which elements to keep/discard:

```{r}
is_lower_case <- function(x) x == tolower(x)

x |> keep_at(is_lower_case)
```

You can now also pass such a function to all other `_at()` functions:

```{r}
x |> 
  modify_at(is_lower_case, \(x) x * 100) |> 
  str()
```

This should mostly make up for the fact they can no longer take tidyselect specifications via `vars()`.

## Flattening and simplification

We've revised the functions related the flattening and simplification of lists.
These were inconsistent across the tidyverse and caused us a lot of confusion internally because folks used the same words to mean different things.
We've also given these functions a common prefix to make it more clear that they all operate on lists.
Additionally, `flatten_dfr()` had some particularly puzzling edge cases when the inputs would be flattened into columns, rather than rows.

-   `flatten()` has been superseded by `list_flatten()`.
-   `flatten_lgl()`, `flatten_int()`, `flatten_dbl()`, and `flatten_chr()` have been superseded by `list_c()`.
-   `flatten_dfr()` and `flatten_dfc()` have been superseded by `list_rbind()` and `list_cbind()` respectively.
-   `map_dfc()` and `map_dfr()` (and their `map2` and `pmap` variants) have been superseded in favour of using the appropriate map function along with `list_rbind()` or `list_cbind()`.
-   `simplify()`, `simplify_all()`, and `as_vector()` have been superseded in favour of `list_simplify()`.
-   `transpose()` has been superseded in favour of `list_transpose()` (#875). It has built-in simplification.

We realise that these functions are used widely in practice so they are superseded: this means that they are not going away but we no longer recommend them, and they will receive only critical bug fixes.

INSERT SOME TABLE

### Flattening

Firstly, we have `list_flatten()` which removes one layer of hierarchy from a list.
In other words, if any of the children of a list are themselves lists, the contents of those lists are inlined into the parent:

```{r}
x <- list(1, list(2, list(3, 4), 5))
x |> str()
x |> list_flatten() |> str()
x |> list_flatten() |> list_flatten() |> str()
```

`list_flatten()` always returns a list; once a list is as flat as it can get (i.e. none of its children contain lists), it leaves the input unchanged.

```{r}
x |> list_flatten() |> list_flatten() |> list_flatten() |> str()
```

### Simplification

`list_simplify()` maintains the length, but produces a simpler type:

```{r}
list(1, 2, 3) |> list_simplify()
list("a", "b", "c") |> list_simplify()
```

Because the length must stay the same, it will only succeed if every element has length 1:

```{r}
#| error: true
list_simplify(list(1, 2, 3:4))
list_simplify(list(1, 2, integer()))
```

Because the result must be a simpler vector, all the components must be compatible:

```{r}
#| error: true
list_simplify(list(1, 2, "a"))
```

If you need to simplify if possible, set `strict = FALSE`:

```{r}
list_simplify(list(1, 2, "a"), strict = FALSE)
```

If you want to be specific the type you want, `list_simplify()` can take the same prototype argument as `map_vec()`:

```{r}
#| error: true
list(1, 2, 3) |> list_simplify(ptype = integer())
list(1, 2, 3) |> list_simplify(ptype = factor())
```

### Concatenation

If you don't want to fix either the type or the length of the list, you might want to concatenate all the pieces together.
There are three functions depending on whether you want to concatenate a vector, or a data frame by rows or by columns.
This is similar to using `do.call(c)` or `do.call(rbind)` but uses vctrs coercion rules

So unlike `list_simplfy()` the elements can be different lengths:

```{r}
list(1, 2, 3) |> list_c()
list(1, 2, 3:4, integer()) |> list_c()
```

But they still must have compatible types:

```{r}
#| error: true

list(1, 2, "a") |> list_c()
```

This makes it clear that `map_dfr()` and `map_dfc()` don't really belong to the map family because they don't maintain a 1-to-1 mapping between input and output: there's reliable no way to associate a row in the output with an element in an input.
For this reason, `map_dfr()` and `map_dfc()` (and the `map2` and `pmap`) variants are superseded and we recommend switching to an explicit call to `list_rbind()` or `list_cbind()` instead:

```{r}
#| eval: false

paths |> map_dfr(read_csv, .id = "path")
# now
paths |> 
  map(read_csv) |> 
  list_rbind(names_to = "path")
```

This new behaviour has some follow on consequences to `accumulate()` and `accumulate2()` which previously had an idiosyncratic approach to simplification.
Also added a new `list_transpose()` which works similarly to `transpose()` but again has consistent simplification mechanism.

### `list_update()` functions

There's one other functions not directly related to flattening and friends, but shares the new `list_` prefix so are worth mentioning here: `list_update()`\
New `list_update()` is similar to `list_modify()` but it doesn't work recursively (this is a mildly confusing feature of `list_modify()` that many folks didn't know about)

```{r}
list(x = 1) |> 
  list_update(y = 2) |>
  str()
```

Here's a quick comparison of `list_update()` vs `list_modify()`: when there's a list on the left-hand side and the right-hand side, `list_modify()` will recurse down.
This is sometimes useful if you want to change a value deep inside a list.

```{r}
list(x = 1, y = list(a = 1)) |> 
  list_update(y = list(b = 2)) |> 
  str()

list(x = 1, y = list(a = 1)) |> 
  list_modify(y = list(b = 1)) |> 
  str()
```

In purrr 1.0.0, `list_modify()` also gains the ability to control

## Acknowledgements
