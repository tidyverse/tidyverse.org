---
output: hugodown::hugo_document

slug: purrr-1-0-0
title: purrr 1.0.0
date: 2022-11-10
author: Hadley Wickham
description: >
    purrr 1.0.0 brings a basket of updates to purrr. We deprecated a number of
    seldom used functions to hone in on the core purpose of purrr while 
    implemented a swath of new features including progress bars, improved 
    error reporting, and much much more!

photo:
  url: https://unsplash.com/photos/YCPkW_r_6uA
  author: Jari Hyt√∂nen

# one of: "deep-dive", "learn", "package", "programming", "roundup", or "other"
categories: [package] 
tags: [purrr]
---

```{=html}
<!--
TODO:
* [x] Look over / edit the post's title in the yaml
* [x] Edit (or delete) the description; note this appears in the Twitter card
* [x] Pick category and tags (see existing with `hugodown::tidy_show_meta()`)
* [x] Find photo & update yaml metadata
* [x] Create `thumbnail-sq.jpg`; height and width should be equal
* [x] Create `thumbnail-wd.jpg`; width should be >5x height
* [] `hugodown::use_tidy_thumbnails()`
* [ ] Add intro sentence, e.g. the standard tagline for the package
* [ ] `usethis::use_tidy_thanks()`
-->
```
```{r}
#| include: false
asciicast::init_knitr_engine()
```

We're happy to announce the release of [purrr](http://purrr.tidyverse.org/) 1.0.0!
purrr enhances R's functional programming toolkit by providing a complete and consistent set of tools for working with functions and vectors.

You can install it from CRAN with:

```{r, eval = FALSE}
install.packages("purrr")
```

purrr is 7 years old, but it's finally made it to 1.0.0!
This was an opportunity to really refine the core purrrpose of purrr, making it more purrrsimonious by moving a number of functions to purrrgatory.
Hopefully these changes are not cat-istrophic

Ok, now that I've got all the purrr related puns out of system ...

You can see a full list of changes in the [release notes](%7B%20github_release%20%7D)

```{r setup}
library(purrr)
```

## Breaking changes

First the bad stuff: we've made some changes to the way purrr operates.
A 1.0.0 release is an opportunity to make some bigger changes to the package to ensure it's on firm footing for the next 10 years.
Tried to make these as minimally invasive as possible.
As part of our new policy, I made pull requests to all [CRAN packages that broke](https://github.com/tidyverse/purrr/issues/969) (except for the 1 that wasn't on GitHub).
Out of \~1,400 dependencies only \~40 had problems.
I've found making these PRs very empathy building and I'm getting much faster at parachuting into a random package that I have no idea what it does and fixing the problems.
This act also gave me confidence that we'll we're deprecating quite a few functions and changing a few special cases, it shouldn't affect much code in the wild.

### pluck and zero-length vectors

Previously, `pluck()` would replace 0-length vectors with the value of `default`.
Now only `NULL` and absent elements will be replaced with `default`:

```{r}
x <- list(y = list(a = character(), b = NULL))
pluck(x, "y", "a", .default = NA)
pluck(x, "y", "b", .default = NA)
pluck(x, "y", "c", .default = NA)
```

This also influences the map family because using an integer vector, character vector, or list automatically calls `pluck()`:

```{r}
x <- list(list(1), list(), list(NULL), list(character()))
map(x, 1, .default = NA)
```

We made this change because it makes purrr more consistent with the rest of the tidyverse which distinguishes zero-length vectors from `NULL`s, and it looks like it was a bug in the original implementation of the function.

### Tidyverse consistency

`map2()` and `pmap()` now obey the tidyverse recycling rules

And `map_chr()` is no longer so permissive.

### Assigning `NULL`

In `pluck<-`, `assign_in()`, `modify()`, `modify2()`, `modify_if()`, `list_modify()` assigning a `NULL` value now creates a `NULL` value in the output, rather than deleting that element.
If you want to delete an entry, now use `zap()`.

```{r}
x <- list(a = 1, b = 2)
x$a <- NULL
str(x)
```

So how do you insert a `NULL` using base R?
You have to switch to `[` and wrap the `NULL` in a list:

```{r}
x <- list(a = 1, b = 2)
x["a"] <- list(NULL)
str(x)
```

Now purrr consistently sets a `NULL` rather than deleting the element.
We wanted all purrr functions to be consistent, and creating `NULL` seemed most useful:

```{r}
x |> list_modify(a = NULL) |> str()
```

If you want to delete it, you'll need to use the special `zap()` sentinel:

```{r}
x |> list_modify(a = zap()) |> str()
```

### Core purpose refinements

A number of functions have been deprecated to keep purrr focused on its core purpose: facilitating functional programming in R.
Deprecating these functions makes purrr easier to maintain because it reduces the surface area for bugs and issues, and it makes purrr easier to learn because there's a clearer common thread that ties together all functions.

-   `cross()` and all its variants have been deprecated because they're slow and buggy, and a better approach already exists in `tidyr::expand_grid()`.

-   `update_list()`, `rerun()`, and the use of tidyselect with `map_at()` and friends have been deprecated because we no longer believe that non-standard evaluation is a good fit for purrr.

-   The `lift_*` family of functions has been deprecated because they rely on a style of function manipulation that is uncommon in R.

-   `prepend()`, `rdunif()`, `rbernoulli()`, `when()`, and `list_along()` have all been deprecated because they don't align with the core purpose of purrr.

-   `splice()` was deprecated because we no longer believe that automatic splicing makes for good UI and there are other ways to achieve the same result.

Deprecation means that the functions will continue to work, you'll get warned once every 8 hours if you use them.
In several years time, we'll release an update which causes the warnings to occur on every time you use them, and a few years after that they'll transformed to throwing errors.

Along with these deprecations, we've also decided not to tackle an important extension: multicore computation.
If you want that, we recommend [furrr](https://furrr.futureverse.org).

## Documentation and licensing

In purrr's documentation, we have switched to using the base pipe (`|>`) instead of magrittr's pie (`|>`) and R's anonymous function short hand (`\(x) x + 1`) instead of formula syntax (`~ .x + 1`).
We believe that these are more readable because they can be used in every package.
Note, that due to the [tidyverse R dependency policy](https://www.tidyverse.org/blog/2019/04/r-version-support/), purrr works in R 3.5, 3.6, 4.0, 4.1, and 4.2, but the base pipe and anonymous function syntax are only available in R 4.0 and later.
To allow purrr to continue to pass `R CMD check`, the examples are automatically disabled in older versions of R.

Similarly, inline with our new tidyverse policy [purrr has been re-licensed](https://www.tidyverse.org/blog/2021/12/relicensing-packages/) with the MIT license.

## Mapping

The map functions have received a major overhaul.
There's four features that you particularly need to know about:

-   Progress bars
-   Errors give location
-   New `map_vec()` generalises `map_lgl()`, `map_int()` and friends.
-   Tidyverse consistency

### Progress bars

```{asciicast}
#| include: false
library(purrr)
options(cli.progress_show_after = 0)
options(cli.progress_clear = FALSE)
```

The map family of function can now produce a progress bar.
This is super useful for long running jobs:

```{asciicast progress}
#| asciicast_at: "all"
#| cache: true
x <- map(1:500, \(x) Sys.sleep(0.01), .progress = TRUE)
```

(For interactive use, the progress bar uses some simple heuristics so that it doesn't show up for very simple jobs.)

In most cases, we expect that `.progress = TRUE` will give you a decent progress bar.
But if you're wrapping the `map()` in a function, you might want to set it to a string that 's used to identify the progress bar:

```{asciicast named-progress}
#| asciicast_at: "all"
#| cache: true
walk(1:100, \(i) Sys.sleep(0.1), .progress = "Saving plots")
```

### Better errors

If there's an error in the function you're mapping, `map()` and friends now tell which element caused the problem:

```{r}
#| error: true
x <- sample(1:500)
map(x, \(x) if (x == 1) stop("Error!") else 10)
```

We hope that this makes your debugging life just a little bit easier!
We have also generally reviewed the error messages throughout purrr in order to make them more actionable.
If you hit a confusing error message, please let us know!

(Don't forget about `safely()` and `possibly()` if you expect failures and want to either ignore or capture them.)

### New `map_vec()`

We've added `map_vec()` (along with `map2_vec()`, and `pmap_vec()`).
They extend `map_lgl()`, `map_int()`, and friends so that you can easily work with dates, factors, date-times and more:

```{r}
1:3 |> map_vec(\(i) factor(letters[i]))
1:3 |> map_vec(\(i) factor(letters[i], levels = letters[4:1]))

1:3 |> map_vec(\(i) as.Date(ISOdate(i + 2022, 10, 5)))
1:3 |> map_vec(\(i) ISOdate(i + 2022, 10, 5))
```

`map_vec()` exists somewhat in the middle of base R's `sapply()` and `vapply()`.
Unlike `sapply()` it will always return a simpler vector, erroring if there's no common type.
Obeys the vctrs rules, which are also used in `dplyr::bind_rows()`, dplyr joins, and many other places.

```{r}
#| error: true
list("a", 1) |> map_vec(identity)
```

If you want to require a certain type of output, supply `.ptype`, making `map_vec()` behaviour more like `vapply()` (but supporting more types).
`ptype` is short for prototype, and should be vector that exemplifies the type of output you expect (this vector is usually empty, but it doesn't have to be).

```{r}
#| error: true

# in vctrs, converting a factor to a character is generally a free transformation:
1:3 |> map_vec(factor, .ptype = character())

# but converting it to an integer is an error
1:3 |> map_vec(factor, .ptype = integer())
```

We don't expect you to know or memorise these rules; our hope is that as we slowly ensure that every tidyverse function follows the same rules that these will be become second nature.

### Tidyverse consistency

vctrs has also had an influence on `map_lgl()`, `map_int()`, `map_int()`, and `map_dbl()`, and they now follow the same coercion rules as vctrs.
This means that:

-   `map_chr(TRUE, identity)`, `map_chr(0L, identity)`, and `map_chr(1L, identity)` are deprecated because we now believe that converting a logical/integer/double to a character vector should require an explicit coercion.

    ```{r}
    # previously
    map_chr(1:4, \(x) x + 1)

    # now
    map_chr(1:4, \(x) as.character(x + 1))
    ```

-   `map_int()` requires that the numeric results be close to integers, rather than silently truncating to integers.
    Compare these two examples:

    ```{r}
    #| error: true
    map_int(1:3, \(x) x / 2)

    map_int(1:3, \(x) x * 2)
    ```

Additionally, `map2()`, `modify2()`, and `pmap()` use tidyverse recycling rules where vectors of length 1 are recycled to any size but all others must have the same length.
This largely

## `keep_at()` and `discard_at()`

purrr has gained a new pair of functions `keep_at()` and `discard_at()`: they work similarly to `keep()` and `discard()` but operate names rather than element contents.

```{r}
x <- list(a = 1, b = 2, c = 3, D = 4, E = 5)

x |> keep_at(c("a", "b", "c")) |> str()
x |> discard_at(c("a", "b", "c")) |> str()
```

Or you can supply a function:

```{r}
x |> keep_at(\(nm) nm %in% letters)
```

The ability to accept a function is also gained by all other `_at()` functions:

```{r}
is_lower_case <- function(x) x %in% letters

x |> modify_at(is_lower_case, \(x) x * 2) |> str()
```

This should mostly make up for the fact they can no longer take tidyselect specifications via `vars()`.

## Flattening and simplification

We've revised the functions related the flattening and simplification of lists.
These were inconsistent across the tidyverse and caused us a lot of confusion internally because folks used the same words to mean different things.
We've also given these functions a common prefix to make it more clear that they all operate on lists.
Additionally, `flatten_dfr()` had some particularly puzzling edge cases when the inputs would be flattened into columns, rather than rows.

-   `flatten()` has been superseded by `list_flatten()`.
-   `flatten_lgl()`, `flatten_int()`, `flatten_dbl()`, and `flatten_chr()` have been superseded by `list_c()`.
-   `flatten_dfr()` and `flatten_dfc()` have been superseded by `list_rbind()` and `list_cbind()` respectively.
-   `map_dfc()` and `map_dfr()` (and their `map2` and `pmap` variants) have been superseded in favour of using the appropriate map function along with `list_rbind()` or `list_cbind()`.
-   `simplify()`, `simplify_all()`, and `as_vector()` have been superseded in favour of `list_simplify()`.
-   `transpose()` has been superseded in favour of `list_transpose()` (#875). It has built-in simplification.

We realise that these functions are used widely in practice so they are superseded: this means that they are not going away but we no longer recommend them, and they will receive only critical bug fixes.

INSERT SOME TABLE

### Flattening

Firstly, we have `list_flatten()` which removes one layer of hierarchy from a list.
In other words, if any of the children of a list are themselves lists, the contents of those lists are inlined into the parent:

```{r}
x <- list(1, list(2, list(3, 4), 5))
x |> str()
x |> list_flatten() |> str()
x |> list_flatten() |> list_flatten() |> str()
```

`list_flatten()` always returns a list; once a list is as flat as it can get (i.e. none of its children contain lists), it leaves the input unchanged.

```{r}
x |> list_flatten() |> list_flatten() |> list_flatten() |> str()
```

### Simplification

`list_simplify()` maintains the length, but produces a simpler type:

```{r}
list(1, 2, 3) |> list_simplify()
list("a", "b", "c") |> list_simplify()
```

Because the length must stay the same, it will only succeed if every element has length 1:

```{r}
#| error: true
list_simplify(list(1, 2, 3:4))
list_simplify(list(1, 2, integer()))
```

Because the result must be a simpler vector, all the components must be compatible:

```{r}
#| error: true
list_simplify(list(1, 2, "a"))
```

If you need to simplify if possible, set `strict = FALSE`:

```{r}
list_simplify(list(1, 2, "a"), strict = FALSE)
```

If you want to be specific the type you want, `list_simplify()` can take the same prototype argument as `map_vec()`:

```{r}
#| error: true
list(1, 2, 3) |> list_simplify(ptype = integer())
list(1, 2, 3) |> list_simplify(ptype = factor())
```

### Concatenation

If you don't want to fix either the type or the length of the list, you might want to concatenate all the pieces together.
There are three functions depending on whether you want to concatenate a vector, or a data frame by rows or by columns.
This is similar to using `do.call(c)` or `do.call(rbind)` but uses vctrs coercion rules

So unlike `list_simplfy()` the elements can be different lengths:

```{r}
list(1, 2, 3) |> list_c()
list(1, 2, 3:4, integer()) |> list_c()
```

But they still must have compatible types:

```{r}
#| error: true

list(1, 2, "a") |> list_c()
```

This makes it clear that `map_dfr()` and `map_dfc()` don't really belong to the map family because they don't maintain a 1-to-1 mapping between input and output: there's reliable no way to associate a row in the output with an element in an input.
For this reason, `map_dfr()` and `map_dfc()` (and the `map2` and `pmap`) variants are superseded and we recommend switching to an explicit call to `list_rbind()` or `list_cbind()` instead:

```{r}
#| eval: false

paths |> map_dfr(read_csv, .id = "path")
# now
paths |> 
  map(read_csv) |> 
  list_rbind(names_to = "path")
```

This new behaviour has some follow on consequences to `accumulate()` and `accumulate2()` which previously had an idiosyncratic approach to simplification.
Also added a new `list_transpose()` which works similarly to `transpose()` but again has consistent simplification mechanism.

### `list_update()` functions

There's one other functions not directly related to flattening and friends, but shares the new `list_` prefix so are worth mentioning here: `list_update()`\
New `list_update()` is similar to `list_modify()` but it doesn't work recursively (this is a mildly confusing feature of `list_modify()` that many folks didn't know about)

```{r}
list(x = 1) |> 
  list_update(y = 2) |>
  str()
```

Here's a quick comparison of `list_update()` vs `list_modify()`: when there's a list on the left-hand side and the right-hand sidem, `list_modify()` will recurse down.
This is sometimes useful if you want to change a value deep inside a list.

```{r}
list(x = 1, y = list(a = 1)) |> 
  list_update(y = list(b = 2)) |> 
  str()

list(x = 1, y = list(a = 1)) |> 
  list_modify(y = list(b = 1)) |> 
  str()
```

In purrr 1.0.0, `list_modify()` also gains the ability to control

## Acknowledgements
