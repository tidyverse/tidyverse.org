---
output: hugodown::hugo_document

slug: fonts-in-r
title: Fonts in R
date: 2025-05-07
author: Thomas Lin Pedersen
description: >
    Taking control of fonts and text rendering in R can be challenging. This
    deep-dive teaches you everything (and then some) you need to know to keep
    your sanity

photo:
  url: https://unsplash.com/photos/flat-lay-photography-of-stamp-lot-p8gzCnZf39k
  author: Kristian Strand

# one of: "deep-dive", "learn", "package", "programming", "roundup", or "other"
categories: [deep-dive]
tags: [systemfonts, textshaping, ragg, svglite, graphics]
---

<style type='text/css'>
pre {
  text-wrap: nowrap;
  overflow-x: scroll;
}
</style>

<!--
TODO:
* [x] Look over / edit the post's title in the yaml
* [x] Edit (or delete) the description; note this appears in the Twitter card
* [x] Pick category and tags (see existing with `hugodown::tidy_show_meta()`)
* [x] Find photo & update yaml metadata
* [x] Create `thumbnail-sq.jpg`; height and width should be equal
* [x] Create `thumbnail-wd.jpg`; width should be >5x height
* [x] `hugodown::use_tidy_thumbnails()`
* [x] Add intro sentence, e.g. the standard tagline for the package
* [x] `usethis::use_tidy_thanks()`
-->

```{r, include = FALSE}
knitr::opts_chunk$set(
  dev = "ragg_png",
  dpi = 300,
  collapse = TRUE,
  comment = "#>"
)
library(tibble)
```

The purpose of this document is to give you the a thorough overview of fonts as it relates to their use in R. However, for this to be possible, it is first necessary to get an understanding of fonts and how they work in digital publishing in general. If you have a thorough understanding of digital typography you may skip to [the next section](#font-handling-in-r).

## Digital typography

Many books can be, and have been, written about the subject of typography. This is not meant to be an exhaustive deep dive into all areas of this vast subject. Rather, it is meant to give you just enough understanding of core concepts and terminology to appreciate how it all plays into using fonts in R.

### Typeface or font?

There is a good chance that you, like 99% of world, use *"font"* as the term describing "the look" of the letters you type. You may, perhaps, have heard the term *"typeface"* as well and thought it synonymous. This is in fact slightly wrong, and a great deal of typography snobbery has been dealt out on that account. It is a rather inconsequential mix-up for the most part, especially because 99% of the population wouldn't bat an eye if you use them interchangeably. However, the distinction between the two serves as a good starting point to talk about other terms in digital typography as well as the nature of font files, so let's dive in.

When most people use the word "font" or "font family", what they are actually describing is a typeface. A **typeface** is a style of lettering that forms a cohesive whole. As an example, consider the well-known "Helvetica" typeface. This name embraces many different weights (bold, normal, light) as well as slanted (italic) and upright. However, all of these variations are all as much Helvetica as the others - they are all part of the same typeface.

If a typeface is font, then what is a font? A **font** is a subset of a typeface, describing a particular variation of the typeface, i.e. the combination of typeface, weight, width, and slant that comes together to describe the specific subset of a typeface that is used. We typically give a specific combination of a name, like "bold" or "medium" or "italic", which we call the **font style**. In other words, the typeface plus a font style gives you a font.

<!-- HW: I think it'd be useful to have an image here with a few fonts from one typeface -->

In the rest of this document we will use the terms typeface and font with the meaning described above.

### Font files

Next, we need to talk about how typefaces are represented for use by computers. Font files record information on how to draw the individual glyphs (characters), but also instructions about how to draw sequences of glyphs like distance adjustments (kerning) and substitution rules (ligatures). Font files typically encode a single font but can encode a full typeface:

```{r}
typefaces <- systemfonts::system_fonts()

# Full typeface in one file
typefaces[typefaces$family == "Helvetica", c("path", "index", "family", "style")]

# One font per font file
typefaces[typefaces$family == "Arial", c("path", "index", "family", "style")]
```

Here, **family** gives the name of the typeface, and **style** the name of the font within that typeface.

It took a considerable number of tries before the world managed to nail the digitial representation of fonts, leading to a proliferation of file types. As an R user, there are three formats that are particularly improtant:

* **TrueType** (ttf/ttc). Truetype is the baseline format that all modern formats stand on top of. It was developed by Apple in the '80s and became popular due to its great balance between size and quality. Fonts can be encoded, either as scalable paths, or as bitmaps of various sizes, the former generally being preferred as it allows for seamless scaling and small file size at the same time.

* ** OpenType** (otf/otc). OpenType was created by Microsoft and Adobe to improve upon TrueType. While TrueType was a great success, it the number of glyphs it could contain was limited and as was its support for selecting different features during [shaping](#text-shaping). OpenType resolved these issues, so if you want access to advanced typography features you'll need a font in OpenType format.

* ** Web Open Font Format** (woff/woff2). TrueType and OpenType tend to create large files. Since a large percentage of the text consumed today is delivered over the internet this creates a problem. WOFF resolves this problem by acting as a compression wrapper around TrueType/OpenType to reduce file sizes while also limiting the number of advanced features provided to those relevant to web fonts. The woff2 format is basically identical to woff except it uses the more efficient [brotli](https://en.wikipedia.org/wiki/Brotli) compression algorithm. WOFF was designed specifically to be delivered over the internet and support is still a bit limited outside of browsers.

While we have mainly talked about font files as containers for the shape of glyphs, they also carries a lot of other information needed for rendering text in a way pleasant for reading. Font level information recordsd a lot of stylistic information about typeface/font, statistics on the number of glyphs and how many different mappings between character encodings and glyphs it contains, and overall sizing information such as the maximum descend of the font, the position of an underline relative to the baseline etc. systemfonts provdies a convenient way to access this data from R:

```{r}
dplyr::glimpse(systemfonts::font_info(family = "Helvetica"))
```

As well as a bunch of information about individual glyphs, 
Further, for each glyph there is a range of information in addition to its shape:

```{r}
systemfonts::glyph_info("j", family = "Helvetica", size = 30)
```

These terms are mostly easily understood with a diagram:

```{r}
#| echo: false
systemfonts::plot_glyph_stats("j", family = "Helvetica", size = 30)
```

<!-- HW: I assume you're planning on exporting this function? I couldn't find it in the dev version and I think it would be suepr useful -->

The `x_advance`  in particular is important when rendering text because it tells you how far to move to the right before rendering the next glyph (ignoring for a bit the concept of kerning)

### Text shaping {#text-shaping}

The next important concept to understand is **text shaping**, which, in the simplest of terms, is convert a succession of characters into sequence of glyphs along with their locations. Important here is the distinction between **characters**, the things you think of as letters, and **glyphs**, which is what the font will draw. For example, think of the character "f", which is often tricky to draw because the "hook" of the f can interfere with other characters. To solve this problem, many typefaces include **ligatures**, like "Ô¨Å", which are used for specific pairs of characaters. Ligatures are extremely important for languages like  Arabic.

Just a few of the challenges of text shaping include kerning, bidirectional text, and font substitution.  **Kerning**, which controls the distance between specific pairs of characters. For example, you can put "VM" a little closer together but "OO" needs to be a little further apart. Kerning is an integral part of all modern text rendering and you will almost solemnly notice it when it is absent (or worse, [wrongly applied](https://www.fastcompany.com/91324550/kerning-on-pope-francis-tomb-is-a-travesty)).

Not every language writes text in the same direction, but regardless of your native script, you are likely to use arabic numerals which are always written left-to-right. This gives rise to the challenge of **bidirectional** (or bidi) text, which mixes text flowing in different directions. This imposes a whole new range of challenges!

Finally, you might request a character that a font doesn't contain. One way to deal with this is to render a glyph representing a missing glyph, usually an empty box or a question mark. But it's typically more useful to use the correct glyph from a different font. This is called **font fallback** and happens all the time for emojis, but can also happen when you suddenly change script without bothering to pick a new font. Font fallback is an imprecise science, typically relying on an operating system font that has a very large number of characters, but might look very different from your existing font.

Once you have determined the order and location of glyphs, you are still not done. Text often needs to be wrapped to fit into a specific width, it may need a specific justification, perhaps, indentation or tracking must be applied, etc. Thankfully, all of this is generally a matter of (often gnarly) math that you just have to get right. That is, all except text wrapping which should happen at the right boundaries, and may need to break up a word and inserting a hyphen etc.

Like I said, the pit of despair is bottomless...

## Font handling in R {#font-handling-in-r}

You hopefully arrive at this section with an appreciation of the horrors that goes into rendering text. If not, maybe this [blog post](https://faultlore.com/blah/text-hates-you/) will convince you. 

Are you still here? Good.

Now that you understand the basics of what goes into handling fonts and text, we can now discuss the details of fonts in R specifically.

### Fonts and text from a user perspective {#fonts-and-text-from-a-user-perspective}

The users perception of working with fonts in R is largely shaped by plots. This means using either base or grid graphics or one of the packages that have been build on top of it, like [ggplot2](https://ggplot2.tidyverse.org). While the choice of tool will affect *where* you specify the font to use, they generally agree on how to specify it.

<!-- HW: I think this would be better as a table -->

#### Base graphics

Font settings are set, either globally with a call to `par()`, or directly when plotting text using `text()` or other calls that result in text being rendered. The relevant arguments are:

-   `family`: the name of the typeface.
-   `font`: the font style.
-   `cra`/`cin`: default size of text specified in either pixels or inches
-   `cex`: a multiplicative scaling factor applied to the default size.

#### Grid graphics

In grid, all graphical parameters including font settings, are set using the `gpar()` function whose return value is assigned to the `gp` argument of relevant functions. The arguments in `gpar()` relevant to text rendering are:

-   `fontfamily`: the name of the typeface.
-   `fontface`: the font style.
-   `fontsize`: the size of the font in points (1/72 inch)
-   `cex`: a multiplication scaling factor applied to `fontsize`.

#### ggplot2

In ggplot2 there are two places you may apply font-related settings. As part of `theme()` using `element_text()`, controlling representation of non-data information such as titles, axis text, etc. And as part of `geom_text()` or other text rendering geoms (including annotation layers). Settings in `element_text()` relevant for fonts are:

-   `family`: the name of the typeface
-   `face`: the font style.
-   `size`: Provides the size of the font in points (1/72 inch)

Settings in `geom_text()` and related geoms relevant for fonts are:

-   `family`: the name of the typeface
-   `fontface`: the font style.
-   `size`: the font size. The default unit is millimeters but may be changed with the `size.unit` argument. If this is set inside `aes()` then the values will first be scaled according to the size scale.

From this brief overview it is clear that in R *fontfamily*/*family* is used to describe the typeface, *font*/*fontface*/*face* is used to select a font from the typeface based on a limited number of styles. Size settings is just a plain mess.

The major limitation in the *fontface* (and friends) setting is that it takes a number, not a string, and you can only select from four options: `1`: plain, `2`: bold, `3`: italic, and `4`: bold-italic. This means, for example, that there's no way to select Futura Condensed Extra Bold. Another limitation is that it's not possible to specify any font variations such as using tabular numbers or stylistic ligatures.

### Fonts and text from a graphics device perspective

<!-- HW: I suspect most people don't know what a graphics device is so you need to explain that here -->

After a user has made a call that renders some text, it is funneled through the graphic system (base or grid), handed off to the graphics engine, which ultimately asks the graphics device to render the text. From the perspective of the graphics device it is much the same information that the user provided which are presented to it. The `text()` method of the device are given an array of characters, the typeface, the size in points, whether or not it is italic, and whether or not it is bold.

<!-- HW: I think a little diagram of the flow here might help -->

This means that the graphics device has to find the approprate font file (using typeface and font style) and shape the text with all that that entails. This is a lot of work, which is why text is handled so inconsistently between graphics devices. Issues can range from not being able to find fonts installed on the computer, to not providing font fallback mechanisms, or even handling right-to-left text. It may also be that certain font file formats are not well supported so that e.g. color emojis are not rendered correctly.

There have been a number of efforts to resolve these problems over the years:

* **extrafont**: Developed by Winston Chang, [extrafont](https://github.com/wch/extrafont) sought to mainly improve the situation for the `pdf()` device which generally only had access to the postscript fonts that comes with R. The package allows the `pdf()` device to get access to TrueType fonts installed on the computer, as well as provide means for embedding the font into the PDF so that it can be opened on systems where the font is not installed. (It also provides the capabilities to to the Windows `png()` device).

* **sysfonts** and **showtext**. These packages are developed by Yixuan Qiu and provide support for system fonts to all graphics devices, by hijacking the `text()` method of the graphics device to text text as polygons or raster images. This guarantees your plots will look the same on every device, but it doesn't do advanced text shaping, so there's no support for ligatures or font substituion. Additionally, it produces large files with inaccessible text when used to produce pdf and svg outputs.

* **systemfonts** and **textshaping**. These packages are developed by me to provide a soup-to-nuts solution to text rendering for graphics devices. [systemfonts](https://systemfonts.r-lib.org) provides access to fonts installed on the system along with font fallback mechanisms, registration of non-system fonts, reading of font files etc. [textshaping](https://github.com/r-lib/textshaping) builds on top of systemfonts and provides a fully modern engine for shaping text. The functionality is exposed both at the R level and at the C level, so that graphics devices can directly access to font lookup and shaping.

We will fosus on systemfonts, because it's designed to give R a fully modern text rendering stack. That unfortunately is impossible to do with coordination with the graphics device, which means to use all these features you need a supported graphics device. There are currently two options:

* The [ragg](https://ragg.r-lib.org) package provides graphics devices for rendering raster graphics in a variety of formats (PNG, JPEG, TIFF) and uses systemfonts and textshaping extensively. 
* The [svglite](https://svglite.r-lib.org) package likewise provides a graphic device for rendering vector graphics to SVG using systemfonts and textshaping for text. 

You might notice there's currently a big hole in this workflow: PDFs. This is something we plan to work on in the future.

### A font workflow based on systemfonts

While textshaping is integral to text rendering, it is not a package that users interact with (but it does all the heavy lifting for the graphics device). Because of this the focus of the remaining text will be on using systemfonts to manage fonts used in plotting. Since we are dealing with systemfonts it follows that a graphics device based on systemfonts must be used, ie. graphics devices from ragg or svglite.

#### Using ragg as default

While there is no way to unilaterally make `ragg::agg_png()` the default device across all aspects of R, it is possible to get close. If you use Positron as the IDE then recent versions will use `ragg::agg_png()` in the plotting pane if ragg is installed. For the RStudio IDE it requires you to set "AGG" as the backend under Global Options \> General \> Graphics. In both cases it is a matter of setting and forgetting and living a blissful existence ever after.

For users of ggplot2 who are fond of the `ggsave()` function for saving output, ragg will also be used for raster output if installed so there is also nothing additional to do there.

The only place you have to be continually mindful of using ragg is in RMarkdown / Quarto documents. Here you have to tell knitr to use ragg as the default device, either by using `knitr::opts_chunk$set(dev = "ragg_png")` in the first code block (works for both RMarkdown and Quarto) or by setting it in the YAML front matter (works only in Quarto) like so:

``` yaml
---
title: "My Document"
format: html
knitr:
  opts_chunk:
    dev: "ragg_png"
---
```

#### Relying on systemfonts

Once you are using a graphics device based on systemfonts there is nothing more to do in order to get access to fonts installed on your computer (you don't need to load systemfonts or anything). Provide the typeface to the `family`/`fontfamily` argument [depending on the graphics system you use](#fonts-and-text-from-a-user-perspective) and enjoy the show. If something seems off, you can use `systemfonts::match_fonts()` to see what font file systemfonts return based on the provided specification

```{r}
systemfonts::match_fonts("Futura", weight = "bold")
```

Likewise you can see what font fallback will be provided for a specific string and font using `systemfonts::font_fallback()`

```{r}
systemfonts::font_fallback("ü§∑‚Äç‚ôÇÔ∏è", family = "Futura", weight = "bold")
```

However, these functions are there mostly to satisfy your curiosity as it all happens automatically at the graphics device layer:

```{r}
#| fig.height: 1
grid::grid.text(
  "FUTURA ü§∑‚Äç‚ôÇÔ∏è",
  gp = grid::gpar(fontfamily = "Futura", fontface = 3, fontsize = 30)
)
```

If you want to get an overview of all the fonts available for use, you can use `systemfonts::system_fonts()`

```{r}
#| eval: false
systemfonts::system_fonts()
```

```{r}
#| echo: false
all_fonts <- systemfonts::system_fonts()
all_fonts <- all_fonts[!grepl("^/Users", all_fonts$path),]
all_fonts
```

#### Overcoming the limitations of R

As discussed above, the R interface presents limitations in terms of which fonts from a typeface can be selected. If you want to use a thin font ‚Äî even if the graphics device is capable of looking it up ‚Äî you have no way of communicating this wish to the device. To overcome this, systemfonts provides `register_variant()` which allows you to register variations of a typeface under a new name. To use the thin font from the Avenir Next typeface you can register it to the Avenir Thin name like so

```{r}
systemfonts::register_variant(
  name = "Avenir Thin",
  family = "Avenir Next",
  weight = "thin"
)
```

You can now use Avenir Thin where you would otherwise specify the typeface

```{r}
#| fig.height: 1
grid::grid.text(
  "Thin weight is soo classy",
  gp = grid::gpar(fontfamily = "Avenir Thin", fontsize = 30)
)
```

The above approach can likewise be used to get access to fonts with a different width than normal.

The last use of `register_variant()` is to turn on various font features otherwise hidden away from you in R

```{r}
#| fig.height: 1
systemfonts::register_variant(
  name = "Avenir Small Caps",
  family = "Avenir Next",
  features = systemfonts::font_feature(
    letters = "small_caps"
  )
)
grid::grid.text(
  "All caps ‚Äî Small caps",
  gp = grid::gpar(fontfamily = "Avenir Small Caps", fontsize = 30)
)
```

#### Fonts from other places

By default, systemfonts provides access to fonts installed on the computer it is executing on. This is usually, but not always, what you want and expect. You might be using a computer where you don't have the rights to install new fonts, or you might not want to go through the hassle of installing a font just to use it for this one plot.

If you want to let systemfonts know about other fonts not installed on your computer you can do so using `add_fonts()`. All it needs is the path to a font file, and all of the fonts present in that file will instantly become available for use. Further, when systemfonts is loaded (which will happen automatically if you use a graphics device dependent on it) it will scan `./fonts` and `~/fonts` and add any fonts it find in these two locations. This means that you can put personal fonts in a fonts folder in your home directory, or project specific fonts in a fonts directory at the root of the project and these fonts will automatically become available in R. This is a great way to ensure that specific fonts are available when you deploy some code to a server.

You don't even have to leave R to populate these folders. systemfonts support a range of online font repositories that can be downloaded from and they are by default placed in `~/fonts` so they are available next time you open R:

```{r}
#| fig.height: 1
systemfonts::get_from_google_fonts("Barrio")

grid::grid.text(
  "A new font a day keeps Tufte away",
  gp = grid::gpar(fontfamily = "Barrio", fontsize = 30)
)
```

If you don't care about how and where, but just want to ensure that a particular font is available before plotting you can use `require_font()`. It will first look to see if the font is already available, and if not, try to download it from one of the repositories it knows about. If it can't find it it will either throw an error (the default) or remap the name to another font on the system so that plotting will still succeed

```{r}
#| fig.height: 1.5
systemfonts::require_font("Barrio")
systemfonts::require_font("Rubik Distressed")

grid::grid.text(
  "There are no bad fonts\nonly bad text",
  gp = grid::gpar(fontfamily = "Rubik Distressed", fontsize = 30)
)
```

By default, `require_font()` places new fonts in a temporary folder so it doesn't pollute your carefully curated collection of fonts.

### Font embedding

If you are using a vector format such as SVG, text is not drawn in the same way as in a raster format such as PNG. Instead the text is passed along and rendering is postponed to when you open the file. This both result in significantly smaller files as well as crisp text at every zoom level you can dream off. However, this comes with a price. Since the text is not rendered before it is opened it relies on the font in use being available on whatever computer is used to open the file with. To deal with this you can embed the font directly into the file so that it travels with the file and is available whenever it is opened.

For PDF the situation is a bit complicated and since no PDF device using systemfonts exist we are glossing over it now. For SVG, however, you can embed fonts using an `@import` statement in the stylesheet. This statement can point to an online location so that the actual font data doesn't have to be written to the file. systemfonts provides facilities to generate URLs for import statements and can provide them in a variety of formats:

```{r}
systemfonts::fonts_as_import("Barrio")
systemfonts::fonts_as_import("Rubik Distressed", type = "link")
```

Further, if the font is not available from an online repository, it can embed the font data directly into the URL

```{r}
substr(systemfonts::fonts_as_import("Chalkduster"), 1, 200)
```

svglite uses this feature to allow seamless font embedding with the `web_fonts` argument. It can take a URL as returned by `fonts_as_import()` or just the name of the typeface and the URL will automatically be resolved. Look at line 6 in the SVG generated below

```{r}
svg <- svglite::svgstring(web_fonts = "Barrio")
grid::grid.text("Example", gp = grid::gpar(fontfamily = "Barrio"))
invisible(dev.off())
svg()
```

## Want more?

This document has mainly focused on how to use the fonts you desire from within R. R has other limitations when it comes to text rendering specifically how to render text that consists of a mix of fonts. This has been solved by [marquee](https://marquee.r-lib.org) and the curious soul can continue there in order to up their skills in rendering text with R

```{r}
#| fig.height: 1
grid::grid.draw(
  marquee::marquee_grob(
    "_This_ **is** the {.red end}",
    marquee::classic_style(base_size = 30)
  )
)
```
