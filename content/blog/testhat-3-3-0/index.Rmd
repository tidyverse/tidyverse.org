---
output: hugodown::hugo_document

slug: testthat-3-3-0
title: testthat 3.3.0
date: 2025-11-05
author: Hadley Wickham
description: >
    testthat 3.3.0 brings improved expectations with better error messages,
    new expectations for common testing patterns, and lifecycle changes including
    the removal of `local_mock()` and `with_mock()`.

photo:
  url: https://unsplash.com/photos/n6vS3xlnsCc
  author: Kelley Bozarth

# one of: "deep-dive", "learn", "package", "programming", "roundup", or "other"
categories: [package] 
tags: []
---

```{r}
#| include: false
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

We're chuffed to announce the release of [testthat](https://testthat.r-lib.org) 3.3.0. testthat is a testing framework for R that makes it easy to turn your existing informal tests into formal, automated tests that you can rerun quickly and easily.

You can install it from CRAN with:

```{r, eval = FALSE}
install.packages("testthat")
```

This blog post highlights the most important changes in this release, including lifecycle changes that removed long-deprecated mocking functions, improvements to expectations and their error messages, and a variety of new features that make testing easier and more robust.

You can see a full list of changes in the [release notes](https://github.com/r-lib/testthat/releases/tag/v3.3.0)

```{r setup}
library(testthat)
```

## Claude Code experiences

I also used this version of testthat as an opportunity to learn Claude Code, and hence it's the first project where I've really used AI to support the development of many features.

Overall it was a successful experiment and helped me close over 100 issues, in what felt like less time than usual. While there might have been a few specific cases where I got 2x performance, on average it feels more like a 10-20% improvement. This is still significant, especially since I'm already an experienced R programmer. I mostly used it for smaller, well-defined tasks where I had a good sense of what was needed. I found it particularly useful for refactoring. It was rare for me to accept what it did as is, but it often got me started.

I also found it generally useful for getting over the "activation energy hump". There were a few issues that had been stagnating for years because they felt like they were going to be hard to do, with relatively limited payoff. I let Claude Code loose on a few of these and found it super useful. Again, it only produced code I was happy with a couple of times, but every time it gave me something to react to (often with strong negative feelings!) and that got me started actually engaging with the problem.

I also experimented with using Claude Code to review PRs. It was just barely useful enough that I kept it turned on for my own PRs, but I didn't bother trying to get it to work for contributed PRs. Most of the time it either gave a thumbs up or bad advice, but every now and then it would pick up a small error.

## Lifecycle changes

The biggest change in this release is that `local_mock()` and `with_mock()` are now defunct. They were deprecated in 3.0.0 (2020-10-31) because it was becoming increasingly clear that the technique that made them work was going to be removed from R. This has happened in R 4.5.0, leading to their removal. This was a fairly disruptive change, affecting ~100 CRAN packages, but it had to be done, and I've been working on notifying package developers since January so everyone had plenty of time to update. Fortunately, the needed changes are generally small, since the newer `local_mocked_bindings()` and `with_mocked_binding()` can solve most additional needs. I also wrote `vignette("mocking")` to make it easier to understand when and how to use mocking.

Other lifecycle changes:

* testthat now requires R 4.1. This follows [our supported version policy](https://tidyverse.org/blog/2019/04/r-version-support/), which documents our commitment to support five versions of R (the current and four previous). We are excited to be able to finally take advantage of the base pipe and compact anonymous functions (i.e. `\(x) x + 1`).

* `is_null()`/`matches()`, deprecated in 2.0.0 (2017-12-19), and `is_true()`/`is_false()`, deprecated in 2.1.0 (2019-04-23), have been removed. These conflicted with other tidyverse functions so we pushed their deprecation through, even though we have generally left the old `test_that()` API untouched.

* `expect_snapshot(binary)`, soft deprecated in 3.0.3 (2021-06-16), is now fully deprecated. `test_files(wrap)`, deprecated in 3.0.0 (2020-10-31), has now been removed.

* There were a few other changes that broke existing packages. The most impactful change was to start checking the inputs to `expect()` which, despite the name, is actually an internal helper. That revealed a surprising number of packages were accidentally using `expect()` instead of `expect_true()` or `expect_equal()`. We technically don't consider this a breaking change because it revealed off-label function usage.

## Expectations and the interactive testing experience

A lot of work in this release was prompted by an overhaul of `vignette("custom-expectations")`, which describes how to create your own expectations that work just like testthat's. This is a long time coming, and as I was working on it, I realized that I didn't really know how to write new expectations and there was a lot of variation in the implementation of existing expectations. So this led to a lot of experimentation and iterating, leading to a swath of improvements:

* All expectations have new failure messages: they now all state what was expected, what was actually received, and, if possible, clearly illustrate the difference.

* Expectations now consistently return the value of the first argument, regardless of whether the expectation succeeds or fails (the only exception is `expect_error()` and friends which return the captured condition). This is a relatively subtle change that won't affect tests that already pass, but it does improve failures when you pipe together multiple expectations.

* A new `pass()` function makes it clear how to signal when an expectation succeeds. All expectations were rewritten to use `pass()` and (the existing) `fail()` instead of `expect()`, which I think makes the flow of logic easier to understand.

* Improved `expect_success()` and `expect_failure()` expectations test that an expectation always returns exactly one success or failure (this ensures that the counts you see in the reporters are always correct).

This new framework helped us write six new expectations:

*   `expect_all_equal()`, `expect_all_true()`, and `expect_all_false()` check that every element of a vector has the same value, giving better error messages than `expect_true(all(...))`:

    ```{r}
    #| error: true

    test_that("some test", {
      x <- c(0.408, 0.961, 0.883, 0.46, 0.537, 0.961, 0.851, 0.887, 0.023)
      expect_all_true(x < 0.95)
    })
    ```

*   `expect_disjoint()` expects values to be absent:

    ```{r}
    #| error: true

    test_that("", {
      expect_disjoint(c("a", "b", "c"), c("c", "d", "e"))
    })
    ```

*   `expect_r6_class()` expects an R6 object:

    ```{r}
    #| error: true

    test_that("", {
      x <- 10
      expect_r6_class(x, "foo")

      x <- R6::R6Class("bar")$new()
      expect_r6_class(x, "foo")
    })
    ```

*   `expect_shape()` expects a specific shape (i.e., `nrow()`, `ncol()`, or `dim()`):

    ```{r}
    #| error: true

    test_that("show off expect_shape() failure messages", {
      x <- matrix(1:9, nrow = 3)
      expect_shape(x, nrow = 4)
      expect_shape(x, dim = c(3, 3, 3))
      expect_shape(x, dim = c(3, 4))
    })
    ```

As you can see from the examples above, when you run a single test interactively (i.e. not as a part of a test suite) you now see exactly how many expectations succeeded and failed.

## Other new features

* testthat generally does a better job of handling nested tests, aka subtests, where you put a `test_that()` inside another `test_that()`, or more typically `it()` inside of `describe()`. Subtests will now generate more informative failure messages, free from duplication, with more informative skips if any subtests don't contain any expectations.

* The snapshot experience has been significantly improved, with all known bugs fixed and some new helpers added: `snapshot_reject()` rejects all modified snapshots by deleting the `.new` variants, and `snapshot_download_gh()` makes it easy to get snapshots off GitHub and into your local package. Additionally, `expect_snapshot()` and friends will now fail when creating a new snapshot on CI, as that's usually a signal that you've forgotten to run the snapshot code locally before committing.

* On CRAN, `test_that()` will automatically skip if a package is not installed, which means that you no longer need to check if suggested packages are installed in your tests.

* `vignette("mocking")` explains mocking in detail, and new `local_mocked_s3_method()`, `local_mocked_s4_method()`, and `local_mocked_r6_class()` make it easier to mock S3 and S4 methods and R6 classes.

* `test_dir()`, `test_check()`, and friends gain a `shuffle` argument that uses `sample()` to randomly reorder the top-level expressions in each test file. This random reordering surfaces dependencies between tests and code outside of any test, as well as dependencies between tests, helping you find and eliminate unintentional dependencies.

* `try_again()` is now publicized, as it's a useful tool for testing flaky code:

    ```{r}
    #| eval: false

    flaky_function <- function(i) {
      if (runif(1) < 0.1) 0 else 1
    }
    test_that("my flaky test is ok", {
      # 10% chance of failure:
      expect_equal(usually_return_1(), 1)

      # 1% chance of failure:
      try_again(1, expect_equal(usually_return_1(), 1))

      # 0.1% chance of failure:
      try_again(2, expect_equal(usually_return_1(), 1))
    })
    ```

* New `skip_unless_r()` skips tests on unsuitable versions of R. It has a convenient syntax so you can use, e.g., `skip_unless_r(">= 4.1.0")` to skip tests that require `...names()`.

* New `SlowReporter` makes it easier to find the slowest tests in your package. You can run it with `devtools::test(reporter = "slow")`.

* New `vignette("challenging-functions")` provides an index to other documentation organized by various challenges.

## Acknowledgements
