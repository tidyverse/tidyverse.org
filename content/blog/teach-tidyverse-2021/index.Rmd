---
output: hugodown::hugo_document

slug: teach-tidyverse-2021
title: Teaching the tidyverse in 2021
date: 2021-08-31
author: Mine Ã‡etinkaya-Rundel
description: >
    Recommendations for teaching the tidyverse in 2021, summarizing package updates most relevant for teaching data science with the tidyverse, particularly to new learners.

photo:
  url: https://unsplash.com/photos/lj5ALRcon4g
  author: Jackie Hope

# one of: "deep-dive", "learn", "package", "programming", or "other"
categories: [learn] 
tags: [tidyverse, teaching]
---

<!--
TODO:
* [ x ] Look over / edit the post's title in the yaml
* [ x ] Edit (or delete) the description; note this appears in the Twitter card
* [ x ] Pick category and tags (see existing with `hugodown::tidy_show_meta()`)
* [ x ] Find photo & update yaml metadata
* [ ] Create `thumbnail-sq.jpg`; height and width should be equal
* [ ] Create `thumbnail-wd.jpg`; width should be >5x height
* [ ] `hugodown::use_tidy_thumbnails()`
* [ ] Add intro sentence, e.g. the standard tagline for the package
* [ ] `usethis::use_tidy_thanks()`
-->

Last summer I wrote, in four parts, about [Teaching the tidyverse in 2020](https://education.rstudio.com/blog/2020/07/teaching-the-tidyverse-in-2020-part-1-getting-started/).
As we quickly approach the end of the summer (in the northern hemisphere) and the start of a new academic year, it seems like a good time to provide a new update for teaching the tidyverse, in 2021.
The main audience for this post is educators who teach the tidyverse and who want to update their teaching materials with updates to the tidyverse that happened over the past year.
Much of what is discussed here has already been covered in package update posts on this blog, but my goal is to summarize the highlights that are most relevant to teaching data science with the tidyverse, particularly to new learners.

Let's get started!

```{r}
library(tidyverse)
```

## Lifecycle stages

The [**lifecycle**](https://lifecycle.r-lib.org/) package is used to manage the lifecycle of functions and features within the tidyverse, with clear messaging about what is still experimental and what the team is moving away from in the future.

The lifecycle stages you might encounter on functions or packages are experimental, stable, deprecated, and superseded.
It's helpful to be aware of the stages (and their associated badges) as you review and revise your teaching materials or as you consider incorporating new tooling into your teaching.

![A diagram showing the transitions between the four main stages: experimental can become stable and stable can become deprecated or superseded.](lifecycle.png)

-   <img src="lifecycle-stable.svg" alt="Stable" style="vertical-align:middle"/> Stable indicates that breaking changes avoided where possible, and they're only made if the long term benefit of such a change exceeds the short term pain of changing existing code.
    If breaking changes are needed, they will occur gradually.
    Note that this badge is generally not shown as it applied to huge majority of functions.
    Teach away any stable functions, they're here to stay for the long run!

-   <img src="lifecycle-deprecated.svg" alt="Deprecated" style="vertical-align:middle"/> If a function is noted as deprecated, this means it has a better alternative available and is scheduled for removal.
    Generally functions will first be soft deprecated and then deprecated.
    Very important functions that become deprecated might next be defunct which means that function continues to exist but the deprecation warning turns into an error.
    An example of a deprecated function is `tibble::data_frame()`, with the preferred alternative `tibble::tibble()`. Arguments to functions can also be deprecated, e.g., in `tidyr::nest()` the new argument `new_col` makes the former `.key` argument not needed, and hence `.key` is deprecated.
    You should avoid teaching functions that are deprecated and correct their usage in your students' code by suggesting the preferred alternative.

-   <img src="lifecycle-superseded.svg" alt="Superseded" style="vertical-align:middle"/> Superseded indicates that there is a known better alternative for the function, but it's not going away.
    Some examples include the following:

    -   `tidyr::spread()` / `tidyr::gather()` vs. `tidyr::pivot_longer()` / `tidyr::pivot_wider()`

    -   Scoped verbs (e.g., `dplyr::mutate_if()`, `dplyr::select_at()`, `dplyr::rename_all()`, etc.) vs. `dplyr::across()`

    -   `dplyr::sample_n()` / `dplyr::sample_frac()` vs. `dplyr::slice_sample()` with `n` and `prop` arguments

    I would recommend not teaching superseded functions to new learners, and for learners who might be aware of them, I would recommend discouraging their use (though not correcting, i.e., no point deductions on a formative assessment), suggesting the alternative.

-   <img src="lifecycle-experimental.svg" alt="Experimental" style="vertical-align:middle"/> Experimental functions are made available so the community can try them out and provide feedback, however they come with no promises for long term stability.
    Some examples include the following:

    -   `dplyr::group_trim()` to unused levels of all factors that are used as grouping variables

    -   in `dplyr::summarize()`: `.groups` argument to define the grouping structure of the result

    -   in `dplyr::mutate()`: `.before` and `.after` arguments to control where new columns should appear

    I would recommend teaching experimental functions with caution, particularly to new learners with whom you might not formally discuss the concept of "lifecycle".
    However there is no reason to discourage use of these functions -- if students have stumbled upon a solution that involves an experimental function or argument and has used it correctly on their own, this is likely a good indication that the experiment is working!

If you'd like to learn more about the tidyverse lifecycle, I recommend the following resources:

-   [lifecycle 1.0.0 blog post](https://www.tidyverse.org/blog/2021/02/lifecycle-1-0-0/)
-   Hadley Wickham's rstudio::global(2021) talk [Maintaining the house the tidyverse built](https://www.rstudio.com/resources/rstudioglobal-2021/maintaining-the-house-the-tidyverse-built/). I think this talk would also be a good resource for software development courses on the topic of maintaining open source software and communicating updates and changes to users.

## Web scraping with rvest

If you've been teaching web scraping with [**rvest**](https://rvest.tidyverse.org/), I recommend updating your teaching materials as you might be able to further simplify and streamline some of the code you present to students.
And if you haven't been teaching web scraping, I recommend reading our paper titled [Web Scraping in the Statistics and Data Science Curriculum: Challenges and Opportunities](https://www.tandfonline.com/doi/full/10.1080/10691898.2020.1787116) where we discuss how web scraping can be implemented in a pedagogically sound and technically executable way at various levels of statistics and data science curricula.

Most recent updates to rvest include the addition of a new function, `html_text2()`, which offers better handling for line breaks.
Suppose you have the following paragraph of text across two lines on a webpage.

```{r}
library(rvest)

html <- minimal_html(
  "<p>  
    This is the first sentence in the paragraph.
    This is the second sentence that should be on the same line as the first sentence.<br>This third sentence should start on a new line.
  </p>"
)
```

With the original `html_text()` function extracting the text out of this paragraph results in the following:

```{r}
html %>% html_text() %>% writeLines()
```

Note that the line breaks in the output do not respect the line break defined with `<br>`.

With the new `html_text2()`, `<br>` is handled appropriately and the line breaks follow the expected pattern.

```{r}
html %>% html_text2() %>% writeLines()
```

The output of `html_text2()` is generally what you want, but note that it is slower than `html_text()`.
This might not make a big difference for teaching web scraping as a new topic, but it is worth keeping in mind when the task involves scraping a large amount of data.
Your choice might also depend on what you're going to do next with the data.
For example, if the next step involves tokenizing the scraped text with `tidytext::unnest_tokens()` you might not care how the line breaks were handled in the first step.

Since this change involves the addition of a new function without changing behaviour in any existing functions, incorporating it into your teaching would require testing `html_text2()` in places where you previously used `html_text()` to see if the result is preferable.

Another important update is that `html_node()` and `html_nodes()` (functions that undoubtedly show up in any lesson on web scraping with rvest) have been superseded in favor of `html_element()` and `html_elements()`.
The motivation behind this update is to better match what learners see when they're first learning about HTML.
When updating teaching materials you should be able to use `html_element()` and `html_elements()` as drop in replacements for `html_node()` and `html_nodes()`, respectively.

For more on updates in rvest, read the [rvest 1.0.0. blog post](https://www.tidyverse.org/blog/2021/03/rvest-1-0-0/) and review the updated [rvest vignette](https://rvest.tidyverse.org/articles/rvest.html).

## Making reproducible examples with reprex

The [**reprex**](https://reprex.tidyverse.org/) package helps users create **repr**oducible **ex**amples for posting to GitHub issues, StackOverflow, in Slack messages or snippets, or even to paste into PowerPoint or Keynote slides by placing the code to be shared in your clipboard.
There has been [many](https://reprex.tidyverse.org/news/index.html#reprex-1-0-0-2021-01-27) [exciting](https://reprex.tidyverse.org/news/index.html#reprex-2-0-0-2021-04-02) developments in reprex over the year.
The one that is perhaps most relevant to teaching are improvements that make it easier to use reprex when working in [RStudio Server](https://www.rstudio.com/products/rstudio/#rstudio-server) and [RStudio Cloud](https://rstudio.cloud/) as well as those that allow using local data when creating a reprex.

Many courses teaches R using RStudio Server or RStudio Cloud since this approach circumvents the need for students to install software and allows the instructor to have full control over the R environment their students are learning in.
When working in RStudio Server or RStudio Cloud, the R code is running in a web browser and for security reasons it's not possible for reprex to place code on your system clipboard.
When creating a reprex in these environments, you can now simply select the relevant code, and run `reprex()`.
This will create a `.md` file containing the contents of the reprex, ready for you to copy via Cmd/Ctrl+C.

<img src="reprex-cloud.png" alt="On the left: RStudio Cloud window with an R script with two lines of code highlighted. On the right: Result after running reprex() in the Console, including a new markdown file with the name vivid-eider_reprex.md that includes the code and the resulting output, commented out, and selected, ready to be copy pasted elsewhere. The viewer pane on the bottom right shows the stylized result of the reprex." width="1000"/>

Another reprex development that will help students, particularly those working on an assignment involving a local data file, create reprexes is the new `wd` argument to set working directory of the reprex.[^1]
Writing a reproducible example with a minimal dataset is better practice, but this can be quite difficult for new learners.
Being able to easily use local data will make it easier for them to benefit from other aspects of reprex earlier on.

[^1]: Turns out this was always possible using the `outfile` argument, but now it's more intuitive!

Being able to create a reprex in the current working directory means you can also benefit from a project-level `.Rprofile` if you happen to have one in your project.
This is likely not going to have implications for new learners, for whom this would be an advanced concept, but it can be helpful for instructors who teach with a different suite than what they locally have installed (e.g., CRAN versions of packages for teaching vs. development versions for personal use).
If this describes you, I recommend using [**renv**](https://rstudio.github.io/renv/index.html) in projects where you keep teaching materials, which uses `.Rprofile` to implement a project-specific package library.
Then, `reprex(wd = ".")` can be used to render using the project-specific library.

For more on updates in reprex, read the blog posts for the [1.0.0](https://www.tidyverse.org/blog/2021/02/reprex-1-0-0/) and [2.0.0](https://www.tidyverse.org/blog/2021/04/reprex-2-0-0/) releases.
If you're new to reprex, start [here](https://reprex.tidyverse.org/articles/articles/learn-reprex.html).

## readr...

**TO DO:** Mention reading many files at once <https://www.tidyverse.org/blog/2021/07/readr-2-0-0/>

## Translations to SQL and data.table

Two packages that provide interfaces for translations between **dplyr** and SQL and [**data.table**](https://rdatatable.gitlab.io/data.table/) code are **dbplyr** and **dtplyr**.
If you're teaching either of these tools alongside the tidyverse, particularly to students who have learned the tidyverse first, the `show_query()` function can be very helpful for translating tidyverse code into syntaxes used by these tools.

dtplyr translates dplyr pipelines into equivalent data.table code.
To start, we first need to create a `lazy_dt()` object which will record the dplyr actions.
Then, we write a dplyr pipeline as usual and save the result.
The result can be viewed by piping it into `as_tibble()` and the data.table code can be viewed with `show_query()`.

```{r}
library(dtplyr)

mtcars_dt <- lazy_dt(mtcars)

cyl_summary <- mtcars_dt %>% 
  group_by(cyl) %>% 
  summarise(across(disp:wt, mean))

# result
cyl_summary %>% as_tibble()

# query
cyl_summary %>% show_query()
```

With recent updates, dtplyr can also translate some tidyr functions to data.table as well, e.g., `pivot_wider()`.
In the following example the process is the same: start with `lazy_dt()`, write a data transformation step using tidyverse code, view the resut with `as_tibble()`, and view the query with `show_query()`.

```{r}
fish_encounters_dt <- lazy_dt(fish_encounters)

fish_encounters_wider <- fish_encounters_dt %>%
  pivot_wider(names_from = station, values_from = seen, values_fill = 0)

# result
fish_encounters_wider %>% as_tibble()

# query
fish_encounters_wider %>% show_query()
```

Similarly, dbplyr translates dplyr pipelines into equivalent SQL code.
The only difference in the following example translating tidyr code to SQL code is the function used in the first step, `memdb_frame()`, which creates a database table.

```{r}
library(dbplyr)

fish_encounters_db <- memdb_frame(fish_encounters)

fish_encounters_wider <- fish_encounters_db %>%
  pivot_wider(names_from = station, values_from = seen, values_fill = 0)

# result
fish_encounters_wider %>% as_tibble()

# query
fish_encounters_wider %>% show_query()
```

If you're interested in learning more about these packages, I recommend the following resources to get started with these packages:

-   [Blog post on dplyr backends](https://www.tidyverse.org/blog/2021/02/dplyr-backends/)
-   [dtplyr translation vignette](https://dtplyr.tidyverse.org/articles/translation.html)
-   [Introduction to dbplyr vignette](https://dbplyr.tidyverse.org/articles/dbplyr.html)

## Building on the tidyverse framework for modeling with tidymodels

The **tidymodels** framework is a collection of packages for modeling and machine learning using tidyverse principles.

```{r}
library(tidymodels)
```

The motivations for tidymodels include

-   providing similar interfaces to models,
-   helping users avoid common machine learning pitfalls, and
-   pedagogical advantages.

### Provide similar interfaces to models

Consider the question "How do you define the the number of trees when fitting a random forest model?"
The answer is generally "depends on the package: `randomForest::randomForest()` uses `ntree`, `ranger::ranger()` uses `num.trees`, Spark's `sparklyr::ml_random_forest()` uses `num_trees`".
The answer with tidymodels is "using the `trees` argument in the `rand_forest()` package, regardless of the engine being used to fit the model.

### Help users avoid common machine learning pitfalls

All tidymodels pipelines start with splitting data into training and testing sets, and the tidymodels framework facilitates keeping the training and testing sets separate since this framework is opioniated about which functions can be applied to testing data.

### Pedagogical advantages

The pedagogical advantages of teaching modeling with the full tidymodels framework may not be clear for fitting simple models with `lm()`.
The simple example belows fitting a linear regression model with a single predictor using base R and using tidymodels.

```{r}
# base R
lm(hwy ~ cty, data = mpg) %>%
  summary()

# tidymodels
linear_reg() %>%
  set_engine("lm") %>%
  fit(hwy ~ cty, data = mpg) %>%
  tidy()
```

The tidymodels approach takes a few more steps, and for a simple model like this, the only advantage is likely in the summarisation step.
With `tidy()` we get the model output as a tibble, which is more straightforward to interact with programmatically and which, by default, omits the significant stars.

```{r}
lm(hwy ~ cty, data = mpg) %>%
  tidy()
```

The pedagogical advantages for the consistent API of the framework are more clear when we move on to different models.
Below you can see examples of how we can fit models using various engines or using the same engine, but different modes.

```{r eval = FALSE}
# different engines
linear_reg() %>%
  set_engine("lm") %>%
  set_mode("regression")

logistic_reg() %>% 
  set_engine("glm") %>%
  set_mode("classification")

rand_forest() %>% 
  set_engine("ranger") %>% 
  set_mode("regression")

decision_tree() %>% 
  set_engine("rpart") %>% 
  set_mode("regression")

# same engine, different modes
svm_linear() %>% 
  set_engine("LiblineaR") %>% 
  set_mode("regression")

svm_linear() %>% 
  set_engine("LiblineaR") %>% 
  set_mode("classification")
```

Another pedagogical advantage, particularly for teaching tidymodels after tidyverse, is the syntax that resembles dplyr pipelines to build recipes.
In the following example we first provide a dplyr pipeline for data wrangling, and then show how a similar set of transformations can be achieved using **recipes**.
The example uses the `email` dataset from the **openintro** package.

```{r eval = FALSE}
# dplyr for data wrangling
openintro::email %>%
  select(-from, -sent_email) %>%
  mutate(
    day_of_week = lubridate::wday(time),
    month = lubridate::month(time)
  ) %>%
  select(-time) %>%
  mutate(
    cc = cut(cc, breaks = c(0, 1)),
    attach = cut(attach, breaks = c(0, 1)),
    dollar = cut(dollar, breaks = c(0, 1))
  ) %>%
  mutate(
    inherit = cut(inherit, breaks = c(0, 1, 5, 10, 20)),
    password = cut(password, breaks = c(0, 1, 5, 10, 20))
  )

# recipes for data preprocessing and feature engineering
# same steps, similar syntax, 
# less bookkeeping for the analyst in modeling setting
recipe(spam ~ ., data = openintro::email) %>%
  step_rm(from, sent_email) %>%
  step_date(
    time, 
    features = c("dow", "month")
    ) %>%
  step_rm(time) %>%
  step_cut(
    cc, 
    attach, 
    dollar, breaks = c(0, 1)
    ) %>%
  step_cut(
    inherit, 
    password, breaks = c(0, 1, 5, 10, 20)
    )
```

### Learning and teaching tidymodels

I recommend the following resources for getting started with tidymodels:

- [Get started with tidymodels](https://www.tidymodels.org/start/)
- [Learn more and go further](https://www.tidymodels.org/learn/)
- [Tidy Modeling with R](https://www.tmwr.org/)

For teaching with tidymodels, Data Science in a Box ([datasciencebox.org](https://datasciencebox.org/)) contains slides, application exercises, computing labs, and homework assignments on modelling and inference with tidymodels:

**TO DO:** Trim down the resources listed?

- Slides and application exercises:
  - [Modelling data](https://datasciencebox.org/making-rigorous-conclusions.html#modelling-data)
  - [Classification and model building](https://datasciencebox.org/making-rigorous-conclusions.html#classification-and-model-building)
  - [Model validation](https://datasciencebox.org/making-rigorous-conclusions.html#model-validation)
  - [Uncertainty quantification](https://datasciencebox.org/making-rigorous-conclusions.html#uncertainty-quantification)
- [Labs](https://datasciencebox.org/making-rigorous-conclusions.html#labs-2)
  - Grading the professor: Fitting and interpreting simple linear regression models
  - Smoking while pregnant: Constructing confidence intervals, conducting hypothesis tests, and interpreting results in context of the data
- [Homework assignments](https://datasciencebox.org/making-rigorous-conclusions.html#homework-assignments-1):
  - Bike rentals in DC: Exploratory data analysis and fitting and interpreting models
  - Exploring the GSS: Fitting and interpreting models
  - Modelling the GSS: Model validation and inference

**TO DO:** Need to add infer: <https://www.tidyverse.org/blog/2021/08/infer-1-0-0/>

## cheatsheets

**TO DO:** Mention cheatsheet updates <https://blog.rstudio.com/2021/08/23/cheat-sheet-updates/>
