<!doctype html><html><head><!doctype html><html lang=en-us><link rel=stylesheet href=/css/fonts.css><link rel=stylesheet href=/css/main-site.css><link rel=stylesheet href=/css/fa5-all.css><style type=text/css>body{background-color:#fff;color:#1a1917}a{color:#38577f}a:hover{color:#42709b}a:focus{outline-color:#42709b}.column25-left .sectionTitle a:hover:not(.current),.column16-left .sectionTitle a:hover:not(.current){color:#1a1917}.icon-attribution,.icon-attribution a{color:#1a1917;opacity:75%}#homeContent .band.first{background-color:#fff}#homeContent .band.second{background-color:#fdeba4}#homeContent .band.third{background-color:#fff}#rStudioHeader{background-color:#1a162d;color:#fff}#rStudioHeader .productName{color:#fff}#rStudioHeader .productName:hover,#rStudioHeader .productName:focus{color:#fdeba4}#rStudioHeader #menu .menuItem.a{background-color:#75aadb;color:#fff}#rStudioHeader #menu .menuItem:hover{background-color:#484557;color:#fff}#rStudioHeader #menu .menuItem.current{background-color:#fff;color:#1a162d;text-decoration:none}#rStudioFooter.band{background-color:#767381}#rStudioFooter .bandContent #copyright{color:#e3eef8}table tbody tr:nth-child(even){background-color:#f7faff}table tbody tr:nth-child(odd){background-color:#fff}.latest{border-top:.5em solid <no value>}.event{-moz-box-shadow:0 0 0 0 rgba(0,0,0,.1);-webkit-box-shadow:0 0 0 0 rgba(0,0,0,.1);box-shadow:0 0 0 0 rgba(0,0,0,.1)}.section .event{background-color:#eab0c41a}.section .event{border-top:7pt solid #a19ea936}.section .event a{color:#1a162d}.section .event{color:#404040}</style><link rel=stylesheet href=/css/tidyverse.css><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Hugo 0.71.1"><title>How parsnip works</title><meta property="og:title" content="How parsnip works"><meta property="og:description" content="A look inside of the parsnip package"><meta property="og:type" content="article"><meta property="og:url" content="https://www.tidyverse.org/blog/2019/04/parsnip-internals/"><meta property="twitter:card" content="summary_large_image"><meta property="og:title" content="How parsnip works - Tidyverse"><meta property="description" content="A look inside of the parsnip package"><meta property="og:description" content="A look inside of the parsnip package"><meta property="og:image" content="https://www.tidyverse.org/blog/2019/04/parsnip-internals/parsnip-internals-sq.jpg"><meta name=twitter:image content="https://www.tidyverse.org/blog/2019/04/parsnip-internals/parsnip-internals-wd.jpg"><link rel=apple-touch-icon sizes=180x180 href=/images/favicons/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/images/favicons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/images/favicons/favicon-16x16.png><link rel=manifest href=/images/favicons/site.webmanifest><link rel=mask-icon href=/images/favicons/safari-pinned-tab.svg><link rel="shortcut icon" href=/images/favicons/favicon.ico><meta name=msapplication-TileColor content="#da532c"><meta name=msapplication-config href=/images/favicons/browserconfig.xml><script type=text/javascript src=/js/jquery-3.5.1.min.js></script><script type=text/javascript src=/js/site.js></script><link rel=icon href=/images/favicon.ico><script type=text/javascript src=/js/clipboard.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin=anonymous></script><script defer data-domain=tidyverse.org,all.tidyverse.org src=https://plausible.io/js/plausible.js></script></head><body><div id=appTidyverseSite class="shrinkHeader alwaysShrinkHeader"><div id=main><div id=rStudioHeader><nav class=band><div class="innards bandContent"><div><a class=productName href=/>Tidyverse</a></div><div id=menu><div id=menuToggler></div><div id=menuItems><a class=menuItem href=/packages/>Packages</a>
<a class="menuItem current" href=/blog/>Blog</a>
<a class=menuItem href=/learn/>Learn</a>
<a class=menuItem href=/help/>Help</a>
<a class=menuItem href=/contribute/>Contribute</a></div></div></div></nav></div><main><div class="band padForHeader pushFooter"><div class=bandContent><div class="full splitColumns withMobileMargins"><div class=column75><h1 class=article-title>How parsnip works</h1><div class=article-header aria-hidden=true><div class=photo><img src=/blog/2019/04/parsnip-internals/parsnip-internals-wd.jpg></div><div class=photoCredit>Photo by <a href=https://unsplash.com/photos/wRoyrBjSBzM>Sharon McCutcheon</a></div></div><span class=article-date><i class="fas fa-calendar-day fa-fw"></i>&nbsp;&nbsp;2019/04/30</span><p style=margin-bottom:.5em;margin-top:.85em><i class="fas fa-tags"></i>&nbsp;
<a href=/tags/tidymodels/>tidymodels</a>,
<a href=/tags/parsnip/>parsnip</a></p><p style=margin-top:.5em><i class="fas fa-user-circle fa-fw"></i>&nbsp;
Max Kuhn, Davis Vaughan, Alex Hayes</p><div class=article-content><p><a href=https://tidymodels.github.io/parsnip/ target=_blank rel=noopener><code>parsnip</code></a> was accepted to CRAN late last year. Our
<a href=https://www.tidyverse.org/articles/2018/11/parsnip-0-0-1/ target=_blank rel=noopener>first blog post</a> was a top-level introduction. Here, we will go into the design of some of the internals. If you end up looking at the package sources, there are going to be times that you might question our sanity. This post is intended to go over some design decisions and provide some context.</p><h1 id=my-first-solution-caret>My first solution: caret
<a href=#my-first-solution-caret><svg class="anchor-symbol" aria-hidden="true" height="26" width="26" viewBox="0 0 22 22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="currentcolor"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h1><p>Having developed
<a href=https://topepo.github.io/caret/ target=_blank rel=noopener><code>caret</code></a> in early 2005, I was not prepared for what it would be like to maintain a package that wrapped more than 200 models. What <code>caret</code> does is to create code <em>modules</em> that define the different aspects of modeling, such as model fitting, prediction, and so on. These code modules are contained in lists, one per specific model. For example, here is one of the simplest lists for
<a href=https://www.rdocumentation.org/packages/MASS/versions/7.3-51.1/topics/lda target=_blank rel=noopener><code>MASS::lda</code></a> (slightly abbreviated):</p><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=nf>list</span><span class=p>(</span>
  <span class=n>label</span> <span class=o>=</span> <span class=s>&#34;Linear Discriminant Analysis&#34;</span><span class=p>,</span>
  <span class=n>library</span> <span class=o>=</span> <span class=s>&#34;MASS&#34;</span><span class=p>,</span>
  <span class=n>type</span> <span class=o>=</span> <span class=s>&#34;Classification&#34;</span><span class=p>,</span>
  <span class=n>fit</span> <span class=o>=</span> <span class=nf>function</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>wts</span><span class=p>,</span> <span class=n>param</span><span class=p>,</span> <span class=n>lev</span><span class=p>,</span> <span class=n>last</span><span class=p>,</span> <span class=n>classProbs</span><span class=p>,</span> <span class=kc>...</span><span class=p>)</span>
    <span class=n>MASS</span><span class=o>::</span><span class=nf>lda</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=kc>...</span><span class=p>)</span>  <span class=p>,</span>
  <span class=n>predict</span> <span class=o>=</span> <span class=nf>function</span><span class=p>(</span><span class=n>modelFit</span><span class=p>,</span> <span class=n>newdata</span><span class=p>,</span> <span class=n>submodels</span> <span class=o>=</span> <span class=kc>NULL</span><span class=p>)</span>
    <span class=nf>predict</span><span class=p>(</span><span class=n>modelFit</span><span class=p>,</span> <span class=n>newdata</span><span class=p>)</span><span class=o>$</span><span class=n>class</span><span class=p>,</span>
  <span class=n>prob</span> <span class=o>=</span> <span class=nf>function</span><span class=p>(</span><span class=n>modelFit</span><span class=p>,</span> <span class=n>newdata</span><span class=p>,</span> <span class=n>submodels</span> <span class=o>=</span> <span class=kc>NULL</span><span class=p>)</span>
    <span class=nf>predict</span><span class=p>(</span><span class=n>modelFit</span><span class=p>,</span> <span class=n>newdata</span><span class=p>)</span><span class=o>$</span><span class=n>posterior</span>
  <span class=p>)</span>
</code></pre></div><p>Some notes:</p><ol><li>✔ The modules are fairly well-defined and mutually exclusive.</li><li>✔ The structure prevents <em>information leakage</em>. The fitting parts are isolated from the prediction parts and the prediction modules only return predictions in a standard format. <code>caret</code> compartmentalizes the modeling process and prevents people from &ldquo;teaching to the test&rdquo; unless they deliberately go out of their way to do so.</li><li>✔ These modules cleanly document
<a href=https://stat.ethz.ch/pipermail/r-devel/2012-January/062935.html target=_blank rel=noopener>issues</a> with using the packages. We&rsquo;d like each model function to have a predictable interface for fitting and prediction, but that&rsquo;s not the reality for many packages. If nothing else, these modules document the idiosyncratic nature of some packages.</li><li>✔ The <code>lda</code> code above is a fairly clean case. Others are not as nice to look at, especially if they can predict multiple sub-models at once or have problematic interfaces.</li><li>✖ There is a lot of code duplication. For this reason, the directory containing the current set of 238 modules is about 1.3MB.</li><li>✖ The system in <code>caret</code> rigidly defines what parameters can be tuned. It is a bit of a walled garden in this respect.</li><li>✔ Code like <code>MASS::lda</code> would be exposed to <code>R CMD check</code> if it is contained in a package&rsquo;s <code>R</code> directory. Because of this, there was a large number of package dependencies in early versions. <code>caret</code> was almost intolerable when it came time for CRAN to check the package. One way that I fixed this was to compile these code modules in an R list object and treat that as <em>data</em> in the package. In this way, the package R files do not contain much specific model code and, many formal dependencies are avoided.</li><li>✔ The ellipses (<code>...</code>) are heavily utilized here. This makes passing other arguments to the underlying fitting function trivial. This is probably still my favorite thing about the S language.</li><li>✖ In some cases, <code>caret</code> needs to grab an object that might be in the ellipses in order to modify the value. For example, the main tuning parameters for
<a href=https://www.rdocumentation.org/packages/rpart/versions/4.1-13/topics/rpart target=_blank rel=noopener><code>rpart</code></a> models are in
<a href=https://www.rdocumentation.org/packages/rpart/versions/4.1-13/topics/rpart.control target=_blank rel=noopener><code>rpart.control</code></a>. If a user passes in an argument by the name of <code>control</code>, it will need to be captured and the appropriate arguments (like <code>cp</code>, <code>maxdepth</code>, or <code>minsplit</code>) are modified without changing the other arguments. That&rsquo;s not hard to do but it eliminates the benefits you get by using the ellipses. In the end, <code>do.call("rpart", args)</code> is used to fit the model. The downside of this is that the <em>data</em> objects are embedded in <code>args</code> and, as an unhappy side-effect, the <em>data set gets embedded in <code>rpart</code>'s call object</em>. That&rsquo;s really bad.</li></ol><p>When I began at RStudio, I had already been thinking about a different and, hopefully more elegant, way to do this for <code>tidymodels</code>.</p><h1 id=a-focus-on-calls-and-quosures>A focus on calls and quosures
<a href=#a-focus-on-calls-and-quosures><svg class="anchor-symbol" aria-hidden="true" height="26" width="26" viewBox="0 0 22 22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="currentcolor"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h1><p>When <code>parsnip</code> fits a model, it constructs a call object that will be evaluated to create the model fit object (<code>rlang::call2</code> and <code>rlang::call_modify</code> are excellent). For example, if we were doing this &ldquo;by-hand&rdquo; for something simple like <code>glm</code>, an initial function using <code>rlang</code> could be:</p><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=nf>library</span><span class=p>(</span><span class=n>rlang</span><span class=p>)</span>
<span class=n>glm_fit</span> <span class=o>&lt;-</span> <span class=nf>function</span><span class=p>(</span><span class=n>formula</span><span class=p>,</span> <span class=n>data</span><span class=p>,</span> <span class=n>evaluate</span> <span class=o>=</span> <span class=kc>FALSE</span><span class=p>,</span> <span class=kc>...</span><span class=p>)</span> <span class=p>{</span>
  <span class=c1># capture the specific arguments and ellipses as quosures:</span>
  <span class=n>args</span> <span class=o>&lt;-</span> <span class=nf>list</span><span class=p>(</span><span class=n>formula</span> <span class=o>=</span> <span class=nf>enquo</span><span class=p>(</span><span class=n>formula</span><span class=p>),</span> <span class=n>data</span> <span class=o>=</span> <span class=n>rlang</span><span class=o>::</span><span class=nf>enquo</span><span class=p>(</span><span class=n>data</span><span class=p>))</span>
  <span class=c1># capture any extra arguments</span>
  <span class=n>args</span> <span class=o>&lt;-</span> <span class=nf>c</span><span class=p>(</span><span class=n>args</span><span class=p>,</span> <span class=n>rlang</span><span class=o>::</span><span class=nf>enquos</span><span class=p>(</span><span class=kc>...</span><span class=p>))</span>
  <span class=c1># make the call</span>
  <span class=n>model_call</span> <span class=o>&lt;-</span> <span class=n>rlang</span><span class=o>::</span><span class=nf>call2</span><span class=p>(</span><span class=s>&#34;glm&#34;</span><span class=p>,</span> <span class=n>.ns</span> <span class=o>=</span> <span class=s>&#34;stats&#34;</span><span class=p>,</span> <span class=o>!!!</span><span class=n>args</span><span class=p>)</span>

  <span class=nf>if </span><span class=p>(</span><span class=n>evaluate</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>res</span> <span class=o>&lt;-</span> <span class=n>rlang</span><span class=o>::</span><span class=nf>eval_tidy</span><span class=p>(</span><span class=n>model_call</span><span class=p>)</span>
  <span class=p>}</span> <span class=n>else</span> <span class=p>{</span>
    <span class=n>res</span> <span class=o>&lt;-</span> <span class=n>model_call</span>
  <span class=p>}</span>
  <span class=n>res</span>
<span class=p>}</span>

<span class=nf>glm_fit</span><span class=p>()</span>
</code></pre></div><pre><code>#&gt; stats::glm(formula = ~, data = ~)
</code></pre><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=nf>glm_fit</span><span class=p>(</span><span class=n>family</span> <span class=o>=</span> <span class=n>stats</span><span class=o>::</span><span class=n>binomial</span><span class=p>)</span>
</code></pre></div><pre><code>#&gt; stats::glm(formula = ~, data = ~, family = ~stats::binomial)
</code></pre><p>When these are printed, the tilde indicates which values are <em>quosures</em>. A
<a href=https://adv-r.hadley.nz/evaluation.html target=_blank rel=noopener>quosure</a> is a combination of an <code>rlang</code> expression and a reference to the environment in which it originated. Since it is partly an expression, the value has not yet been evaluated inside of <code>glm_fit()</code>. For this reason, when we pass <code>family = stats::binomial</code>, the object
<a href=https://www.rdocumentation.org/packages/stats/versions/3.5.1/topics/family target=_blank rel=noopener><code>stats::binomial</code></a> is <em>not</em> evaluated. If it were, the value of that object would be embedded into the call (type <code>unclass(binomial())</code> at an R prompt to see what this looks like).</p><p>Here&rsquo;s a better example:</p><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=nf>glm_fit</span><span class=p>(</span><span class=n>mpg</span> <span class=o>~</span> <span class=n>.,</span> <span class=n>data</span> <span class=o>=</span> <span class=n>mtcars</span><span class=p>,</span> <span class=n>x</span> <span class=o>=</span> <span class=kc>FALSE</span><span class=p>)</span>
</code></pre></div><pre><code>#&gt; stats::glm(formula = ~(mpg ~ .), data = ~mtcars, x = ~FALSE)
</code></pre><p>The
<a href=https://www.rdocumentation.org/packages/rlang/versions/0.2.2/topics/eval_tidy_ target=_blank rel=noopener><code>eval_tidy</code></a> function can evaluate the quosure arguments when the call itself is evaluated. We get our model object as expected:</p><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=nf>glm_fit</span><span class=p>(</span><span class=n>mpg</span> <span class=o>~</span> <span class=n>.,</span> <span class=n>data</span> <span class=o>=</span> <span class=n>mtcars</span><span class=p>,</span> <span class=n>x</span> <span class=o>=</span> <span class=kc>FALSE</span><span class=p>,</span> <span class=n>evaluate</span> <span class=o>=</span> <span class=kc>TRUE</span><span class=p>)</span>
</code></pre></div><pre><code>#&gt; 
#&gt; Call:  stats::glm(formula = ~(mpg ~ .), data = ~mtcars, x = ~FALSE)
#&gt; 
#&gt; Coefficients:
#&gt; (Intercept)          cyl         disp           hp         drat           wt  
#&gt;     12.3034      -0.1114       0.0133      -0.0215       0.7871      -3.7153  
#&gt;        qsec           vs           am         gear         carb  
#&gt;      0.8210       0.3178       2.5202       0.6554      -0.1994  
#&gt; 
#&gt; Degrees of Freedom: 31 Total (i.e. Null);  21 Residual
#&gt; Null Deviance:	    1130 
#&gt; Residual Deviance: 147 	AIC: 164
</code></pre><p>For <code>parsnip</code>, there are utility functions that create the call and others to evaluate it. This means that the only model-related information needed to by the package to define the general <code>glm</code> fitting function would be:</p><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=n>glm_data</span> <span class=o>&lt;-</span> <span class=nf>list</span><span class=p>(</span><span class=n>func</span> <span class=o>=</span> <span class=s>&#34;glm&#34;</span><span class=p>,</span> <span class=n>package</span> <span class=o>=</span> <span class=s>&#34;stats&#34;</span><span class=p>,</span> <span class=n>required_args</span> <span class=o>=</span> <span class=nf>c</span><span class=p>(</span><span class=s>&#34;formula&#34;</span><span class=p>,</span> <span class=s>&#34;data&#34;</span><span class=p>))</span>
</code></pre></div><p>All of the other arguments are assembled from the model specification object or extra arguments provided to
<a href=https://tidymodels.github.io/parsnip/reference/set_engine.html target=_blank rel=noopener><code>set_engine()</code></a> and
<a href=https://tidymodels.github.io/parsnip/reference/fit.html target=_blank rel=noopener><code>fit()</code></a>. This allows for a fairly compact representation of the information for the fitting module. Also, it does not expose the code in a way that requires a package dependency and doesn&rsquo;t contaminate the model call with actual object values. The same strategy can be used to produce predictions and other quantities.</p><p>There are some other niceties too. If a package, like
<a href="https://cran.r-project.org/package=glmnet" target=_blank rel=noopener><code>glmnet</code></a> has a non-formula interface and requires the predictors to be in a matrix, that fitting function can just insert <code>x = as.matrix(x)</code> into the <code>glmnet</code> call instead of doing the matrix conversion prior to the model fit.</p><p>Unsurprisingly, most model are more complex than our <code>glm</code> example. There are some modeling packages, such as
<a href=https://keras.rstudio.com/ target=_blank rel=noopener><code>keras</code></a> or
<a href="https://cran.r-project.org/package=xgboost" target=_blank rel=noopener><code>xgboost</code></a>, that don&rsquo;t have a one-line call to fit the model (see the <code>keras</code> regression example
<a href=https://keras.rstudio.com/articles/tutorial_basic_regression.html target=_blank rel=noopener>here</a>). In this case, a wrapper function is needed and this most likely results in an extra package dependency.</p><p>Also, some prediction methods give back results that require post-processing. For example, class probability predictions for a multiclass <code>xgboost</code> model come back as <em>a vector</em>. For example, if you were to predict four samples of iris data, you would get a 12 element vector back that requires you to reshape the results into the appropriate 4x3 data frame. <code>parsnip</code> handles these by having slots for pre-processing the data and/or post-processing the raw prediction results. More information can be found on the
<a href=https://tidymodels.github.io/parsnip/articles/articles/Scratch.html target=_blank rel=noopener>vignette for creating a model object</a>. Keep in mind that, as we and other contributors work with the package more, these internals may slightly change in the first few versions.</p><p>Also, a lot of the package code revolves around getting the arguments right. There are some default arguments set by the package, such as <code>family = binomial</code> for logistic regression. These defaults can be overwritten but may also depend on the mode of the model (e.g. regression, classification, etc.). There are also some arguments that <code>parsnp</code> <em>protects</em> in case the user tries to modify them (e.g. <code>data</code>). Finally, the main arguments to <code>parsnip</code> model functions are standardized and need to eventually be converted back to their engine-specific names.</p><h1 id=the-down-side-to-using-calls>The down-side to using calls
<a href=#the-down-side-to-using-calls><svg class="anchor-symbol" aria-hidden="true" height="26" width="26" viewBox="0 0 22 22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="currentcolor"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h1><p>Suppose that you are fitting a random forest regression model and want to tune over <code>mtry</code>, the number of randomly selected predictors to evaluate at each split of the tree. This is a function of the data since it depends on the number of predictors. A simplistic version of the code that iterates over <code>mtry</code> might look like:</p><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=nf>library</span><span class=p>(</span><span class=n>tidymodels</span><span class=p>)</span>
<span class=n>rf_model</span> <span class=o>&lt;-</span> <span class=nf>rand_forest</span><span class=p>(</span><span class=n>mode</span> <span class=o>=</span> <span class=s>&#34;regression&#34;</span><span class=p>)</span>

<span class=nf>for </span><span class=p>(</span><span class=n>i</span> <span class=n>in</span> <span class=m>1</span><span class=o>:</span><span class=m>4</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>new_rf</span> <span class=o>&lt;-</span> 
    <span class=n>rf_model</span> <span class=o>%&gt;%</span> 
    <span class=nf>update</span><span class=p>(</span><span class=n>mtry</span> <span class=o>=</span> <span class=n>i</span><span class=p>)</span>
  <span class=n>rf_fit</span> <span class=o>&lt;-</span> 
    <span class=n>new_rf</span> <span class=o>%&gt;%</span>
    <span class=nf>set_engine</span><span class=p>(</span><span class=s>&#34;ranger&#34;</span><span class=p>)</span> <span class=o>%&gt;%</span>
    <span class=nf>fit</span><span class=p>(</span><span class=n>Sepal.Width</span> <span class=o>~</span> <span class=n>.,</span> <span class=n>data</span> <span class=o>=</span> <span class=n>iris</span><span class=p>)</span>
  <span class=c1># now evaluate the model for performance</span>
<span class=p>}</span>

<span class=c1># what is the current value of `mtry`? </span>
<span class=n>new_rf</span>
</code></pre></div><pre><code>#&gt; Random Forest Model Specification (regression)
#&gt; 
#&gt; Main Arguments:
#&gt;   mtry = i
</code></pre><p>The specification depends on <code>i</code> and its value is not in <code>new_rf</code>, only a reference to a symbol <code>i</code> in the global environment. What if the value of <code>i</code> changes?</p><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=n>i</span> <span class=o>&lt;-</span> <span class=m>300</span>
<span class=n>new_rf</span> <span class=o>%&gt;%</span>
  <span class=nf>set_engine</span><span class=p>(</span><span class=s>&#34;ranger&#34;</span><span class=p>)</span> <span class=o>%&gt;%</span>
  <span class=nf>fit</span><span class=p>(</span><span class=n>Sepal.Width</span> <span class=o>~</span> <span class=n>.,</span> <span class=n>data</span> <span class=o>=</span> <span class=n>iris</span><span class=p>)</span>
</code></pre></div><pre><code>#&gt; Error in ranger::ranger(formula = formula, data = data, mtry = ~i, num.threads = 1, : User interrupt or internal error.
</code></pre><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=c1># mtry should be between 1 and 4 for these data. </span>
</code></pre></div><p>In this context, using quosures for parameter values is problematic because (by default) their values are not frozen when the specification is created. However, we can fix this using
<a href=https://adv-r.hadley.nz/quasiquotation.html target=_blank rel=noopener>quasiquotiation</a>. The value of <code>i</code> can be embedded into the call using <code>!!</code>:</p><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=nf>for </span><span class=p>(</span><span class=n>i</span> <span class=n>in</span> <span class=m>1</span><span class=o>:</span><span class=m>4</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>new_rf</span> <span class=o>&lt;-</span> 
    <span class=n>rf_model</span> <span class=o>%&gt;%</span> 
    <span class=nf>update</span><span class=p>(</span><span class=n>mtry</span> <span class=o>=</span> <span class=o>!!</span><span class=n>i</span><span class=p>)</span>
<span class=p>}</span>

<span class=c1># What is the current value of `mtry` now? </span>
<span class=n>new_rf</span>
</code></pre></div><pre><code>#&gt; Random Forest Model Specification (regression)
#&gt; 
#&gt; Main Arguments:
#&gt;   mtry = 4
</code></pre><p>One other downside is related to the <em>data</em> used in the call. In the random forest example above, the value of <code>mtry</code> is dependent on the number of predictors. What if you don&rsquo;t know how many predictors you have until the model is fit? How could you then specify <code>mtry</code>?</p><p>This could happen for a few reasons. For example, if you are using a <code>recipe</code> that has a filter based on reducing correlation, the number of predictors may not be known until the recipe is prepped (and the number may vary inside of resampling). A more common example is related to dummy variables. If I use <code>fit_xy()</code> instead of <code>fit()</code> in the code above, the <code>Species</code> predictor in the iris data is expanded from one column into two dummy variable columns just prior to the model fit. This could affect the possible range of <code>mtry</code> values.</p><p>There are a few ways to get around this. The first (and worst) is to use the data in an expression. Since <code>mtry</code> isn&rsquo;t evaluated until the model fit, you could try to use <code>mtry = floor(sqrt(ncol(data)))</code>. That&rsquo;s very brittle for a few different reasons. For one, <em>you</em> may use the <code>parsnip</code> interface <code>fit(formula, data)</code>, but the underlying model may be <code>model_fn(x, y)</code> and the <code>data</code> object doesn&rsquo;t exist when the model call is evaluated.</p><p>For this reason, we added
<a href=https://tidymodels.github.io/parsnip/reference/descriptors.html target=_blank rel=noopener>data descriptors</a> to <code>parsnip</code>. These are small functions that only work when the model is being fit and they capture relevant aspects of the data at <strong>the time of fit</strong>. For example, the function <code>.obs()</code> can be used in an argument value to reference the number of rows in the data. To illustrate, the argument <code>min_n</code> for a random forest model corresponds to how many data points are required to make further splits. For regression models, this defaults to 5 when using
<a href="https://cran.r-project.org/package=ranger" target=_blank rel=noopener><code>ranger</code></a>. Suppose you want this to be one-tenth of the data but at least 8. If your data are being resampled, you might not know the training set size. You could use:</p><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=n>rf_model</span> <span class=o>%&gt;%</span> 
    <span class=nf>update</span><span class=p>(</span><span class=n>min_n</span> <span class=o>=</span> <span class=nf>max</span><span class=p>(</span><span class=m>8</span><span class=p>,</span> <span class=nf>floor</span><span class=p>(</span><span class=nf>.obs</span><span class=p>()</span><span class=o>/</span><span class=m>10</span><span class=p>)))</span> <span class=o>%&gt;%</span>
    <span class=nf>set_engine</span><span class=p>(</span><span class=s>&#34;ranger&#34;</span><span class=p>)</span> <span class=o>%&gt;%</span>
    <span class=nf>fit</span><span class=p>(</span><span class=n>Sepal.Width</span> <span class=o>~</span> <span class=n>.,</span> <span class=n>data</span> <span class=o>=</span> <span class=n>iris</span><span class=p>)</span>
</code></pre></div><pre><code>#&gt; parsnip model object
#&gt; 
#&gt; Ranger result
#&gt; 
#&gt; Call:
#&gt;  ranger::ranger(formula = formula, data = data, min.node.size = ~max(8,      floor(.obs()/10)), num.threads = 1, verbose = FALSE, seed = sample.int(10^5,      1)) 
#&gt; 
#&gt; Type:                             Regression 
#&gt; Number of trees:                  500 
#&gt; Sample size:                      150 
#&gt; Number of independent variables:  4 
#&gt; Mtry:                             2 
#&gt; Target node size:                 15 
#&gt; Variable importance mode:         none 
#&gt; Splitrule:                        variance 
#&gt; OOB prediction error (MSE):       0.0827 
#&gt; R squared (OOB):                  0.565
</code></pre><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=c1># The math checks out for the &#34;Target node size&#34; above:</span>
<span class=nf>max</span><span class=p>(</span><span class=m>8</span><span class=p>,</span> <span class=nf>floor</span><span class=p>(</span><span class=nf>nrow</span><span class=p>(</span><span class=n>iris</span><span class=p>)</span><span class=o>/</span><span class=m>10</span><span class=p>))</span>
</code></pre></div><pre><code>#&gt; [1] 15
</code></pre><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=c1># Does this work outside of the function call? </span>
<span class=nf>max</span><span class=p>(</span><span class=m>8</span><span class=p>,</span> <span class=nf>floor</span><span class=p>(</span><span class=nf>.obs</span><span class=p>()</span><span class=o>/</span><span class=m>10</span><span class=p>))</span>
</code></pre></div><pre><code>#&gt; Descriptor context not set
</code></pre><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=c1># Nope!</span>
</code></pre></div><p>The different descriptors should enable a wide variety of values for tuning parameters.</p><h1 id=why-not-just-evaluate-the-arguments>Why not just evaluate the arguments?
<a href=#why-not-just-evaluate-the-arguments><svg class="anchor-symbol" aria-hidden="true" height="26" width="26" viewBox="0 0 22 22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="currentcolor"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h1><p>In many cases, the model specification arguments (e.g. <code>mtry</code> or <code>min_n</code>) and engine arguments are simple objects or scalar values. It makes sense to quote <code>data</code>, <code>x</code> or <code>y</code> but why not just evaluate the other arguments as usual?</p><p>There are a few reasons. First, there are some arguments whose evaluation should be deferred. For example, <code>stan</code> and <code>ranger</code> models have their own random seed arguments. To enable reproducibility, <code>parsnip</code> gives these function default values of <code>seed = sample.int(10^5, 1)</code>. If this argument were unquoted, then the seed value would be fixed when the package was compiled. There are solutions for this simple example though.</p><p>As seen above for data descriptors, there is the need to wait for some argument values to be evaluated at the same time that the call is evaluated. Originally, <code>parsnip</code> immediately evaluated almost all of the arguments and our advice was to have users quote special arguments using <code>rlang::expr()</code>. The feedback on this aspect of <code>parsnip</code> was uniformity unfavorable since it would require many casual users to learn <code>rlang</code> and metaprogramming techniques. For this reason, we moved the metaprogramming parts within the function to accomplish the same goals but without the user being required to understand the technical minutiae. When a user uses an argument like <code>min_n = max(8, floor(.obs()/10))</code>, the use of quosures is hidden from view and it looks like they are using an ordinary function called <code>.obs()</code>.</p><p>One final reason to leave arguments unevaluated in the model specification is related to <em>future plans</em>. As previously mentioned, <code>caret</code> rigidly defined which model parameters were available for performance tuning. The approach taken by <code>parsnip</code> is very much the opposite. We want to enable users to tune any aspect of the model that they see fit, including some of the engine specific parameters.</p><p>For example, when fitting a Bayesian regression model, a user might want to tune over how diffuse the prior distribution should be and so on. Rather than formally defining every possible tunable parameter, <code>parsnip</code> allows the user to have a <em>placeholder</em> for parameters in the model specification that declares, &ldquo;I want to change this parameter, but I don&rsquo;t know what the exact value should be.&rdquo;</p><p>To do this, a special function called <code>varying()</code> is used. A model cannot be fit if it has any varying parameters but future packages will be able to detect any of these parameters and construct tuning grids accordingly. The parameter values can be changed to specific candidate values, and these are then tested to see which value is the most appropriate. The code to do this is not ready at this point and will be part of another package. However, we can demonstrate how this happens inside of <code>parsnip</code>:</p><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=n>lr_stan_spec</span> <span class=o>&lt;-</span>
  <span class=nf>logistic_reg</span><span class=p>()</span> <span class=o>%&gt;%</span>
  <span class=nf>set_engine</span><span class=p>(</span>
    <span class=s>&#34;stan&#34;</span><span class=p>,</span>
    <span class=n>iter</span> <span class=o>=</span> <span class=m>5000</span><span class=p>,</span>
    <span class=n>prior_intercept</span> <span class=o>=</span> <span class=n>rstanarm</span><span class=o>::</span><span class=nf>student_t</span><span class=p>(</span><span class=n>df</span> <span class=o>=</span> <span class=nf>varying</span><span class=p>()),</span>
    <span class=n>seed</span> <span class=o>=</span> <span class=m>2347</span>
  <span class=p>)</span>

<span class=c1># Which, if any, arguments, should be tuned?</span>
<span class=nf>varying_args</span><span class=p>(</span><span class=n>lr_stan_spec</span><span class=p>)</span>
</code></pre></div><pre><code>#&gt; # A tibble: 5 x 4
#&gt;   name            varying id           type      
#&gt;   &lt;chr&gt;           &lt;lgl&gt;   &lt;chr&gt;        &lt;chr&gt;     
#&gt; 1 penalty         FALSE   logistic_reg model_spec
#&gt; 2 mixture         FALSE   logistic_reg model_spec
#&gt; 3 iter            FALSE   logistic_reg model_spec
#&gt; 4 prior_intercept TRUE    logistic_reg model_spec
#&gt; 5 seed            FALSE   logistic_reg model_spec
</code></pre><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=n>nnet_spec</span> <span class=o>&lt;-</span>
  <span class=nf>mlp</span><span class=p>(</span>
    <span class=n>hidden_units</span> <span class=o>=</span> <span class=nf>varying</span><span class=p>(),</span>
    <span class=n>epochs</span> <span class=o>=</span> <span class=nf>varying</span><span class=p>(),</span>
    <span class=n>dropout</span> <span class=o>=</span> <span class=nf>varying</span><span class=p>()</span>
  <span class=p>)</span> <span class=o>%&gt;%</span>
  <span class=nf>set_engine</span><span class=p>(</span>
    <span class=s>&#34;keras&#34;</span><span class=p>,</span> 
    <span class=n>batch_size</span> <span class=o>=</span> <span class=nf>varying</span><span class=p>(),</span>
    <span class=n>callbacks</span> <span class=o>=</span> <span class=nf>callback_early_stopping</span><span class=p>(</span><span class=n>monitor</span> <span class=o>=</span> <span class=s>&#39;loss&#39;</span><span class=p>,</span> <span class=n>min_delta</span> <span class=o>=</span> <span class=nf>varying</span><span class=p>())</span>
  <span class=p>)</span>

<span class=nf>varying_args</span><span class=p>(</span><span class=n>nnet_spec</span><span class=p>)</span>
</code></pre></div><pre><code>#&gt; # A tibble: 7 x 4
#&gt;   name         varying id    type      
#&gt;   &lt;chr&gt;        &lt;lgl&gt;   &lt;chr&gt; &lt;chr&gt;     
#&gt; 1 hidden_units TRUE    mlp   model_spec
#&gt; 2 penalty      FALSE   mlp   model_spec
#&gt; 3 dropout      TRUE    mlp   model_spec
#&gt; 4 epochs       TRUE    mlp   model_spec
#&gt; 5 activation   FALSE   mlp   model_spec
#&gt; 6 batch_size   TRUE    mlp   model_spec
#&gt; 7 callbacks    TRUE    mlp   model_spec
</code></pre><p>In the <code>keras</code> example, the argument names in <code>nnet_spec</code> names match up with objects in the
<a href=https://tidymodels.github.io/dials/ target=_blank rel=noopener><code>dials</code></a> package, and it will be possible to automatically create tuning grids for all of the parameters.</p><p>By avoiding evaluation in the model specification, we are enabling some interesting upcoming features.</p><p>Also, this feature will also be used with recipes and other future packages. This will enable joint optimization of parameters associated with pre-processing, model fitting, and post-processing activities.</p></div></div><div class=column25><div class="section hideOnMobile"></div><div class=section></div></div></div></div></div><div id=rStudioFooter class=band><div class=bandContent><div id=copyright>The tidyverse is proudly supported by <a class=rstudioLogo href=https://posit.co/ aria-label="Posit Homepage"></a></div><div id=logos><a href=https://www.tidyverse.org/google_privacy_policy>Privacy policy</a>
<a href=https://github.com/tidyverse class="footerLogo gitHub" aria-label="Tidyverse GitHub organization"></a><a href=https://twitter.com/hashtag/rstats class="footerLogo twitter" aria-label="rstats hashtag on twitter.com"></a></div></div></div></div></div><script src=/js/math-code.js></script><script type=text/x-mathjax-config>
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
  }
});
</script><script async src="//cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script type=application/javascript>var dnt=(navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack);var doNotTrack=(dnt=="1"||dnt=="yes");if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');if(window.sessionStorage){var GA_SESSION_STORAGE_KEY='ga:clientId';ga('create','UA-115082821-1',{'storage':'none','clientId':sessionStorage.getItem(GA_SESSION_STORAGE_KEY)});ga(function(tracker){sessionStorage.setItem(GA_SESSION_STORAGE_KEY,tracker.get('clientId'));});}
ga('set','anonymizeIp',true);ga('send','pageview');}</script></body></html></div></div></body></html>