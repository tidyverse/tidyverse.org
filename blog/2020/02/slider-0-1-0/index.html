<!doctype html><html><head><!doctype html><html lang=en-us><link rel=stylesheet href=/css/fonts.css><link rel=stylesheet href=/css/main-site.css><link rel=stylesheet href=/css/fa5-all.css><style type=text/css>body{background-color:#fff;color:#1a1917}a{color:#38577f}a:hover{color:#42709b}a:focus{outline-color:#42709b}.column25-left .sectionTitle a:hover:not(.current),.column16-left .sectionTitle a:hover:not(.current){color:#1a1917}.icon-attribution,.icon-attribution a{color:#1a1917;opacity:75%}#homeContent .band.first{background-color:#fff}#homeContent .band.second{background-color:#fdeba4}#homeContent .band.third{background-color:#fff}#rStudioHeader{background-color:#1a162d;color:#fff}#rStudioHeader .productName{color:#fff}#rStudioHeader .productName:hover,#rStudioHeader .productName:focus{color:#fdeba4}#rStudioHeader #menu .menuItem.a{background-color:#75aadb;color:#fff}#rStudioHeader #menu .menuItem:hover{background-color:#484557;color:#fff}#rStudioHeader #menu .menuItem.current{background-color:#fff;color:#1a162d;text-decoration:none}#rStudioFooter.band{background-color:#767381}#rStudioFooter .bandContent #copyright{color:#e3eef8}table tbody tr:nth-child(even){background-color:#f7faff}table tbody tr:nth-child(odd){background-color:#fff}.latest{border-top:.5em solid <no value>}.event{-moz-box-shadow:0 0 0 0 rgba(0,0,0,.1);-webkit-box-shadow:0 0 0 0 rgba(0,0,0,.1);box-shadow:0 0 0 0 rgba(0,0,0,.1)}.section .event{background-color:#eab0c41a}.section .event{border-top:7pt solid #a19ea936}.section .event a{color:#1a162d}.section .event{color:#404040}</style><link rel=stylesheet href=/css/tidyverse.css><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=generator content="Hugo 0.71.1"><title>slider 0.1.0</title><meta property="og:title" content="slider 0.1.0"><meta property="og:description" content="slider 0.1.0 is now available on CRAN. It provides a family of general purpose sliding window functions."><meta property="og:type" content="article"><meta property="og:url" content="https://www.tidyverse.org/blog/2020/02/slider-0-1-0/"><meta property="twitter:card" content="summary_large_image"><meta property="og:title" content="slider 0.1.0 - Tidyverse"><meta property="description" content="slider 0.1.0 is now available on CRAN. It provides a family of general purpose sliding window functions."><meta property="og:description" content="slider 0.1.0 is now available on CRAN. It provides a family of general purpose sliding window functions."><meta property="og:image" content="https://www.tidyverse.org/blog/2020/02/slider-0-1-0/thumb-sq.jpg"><meta name=twitter:image content="https://www.tidyverse.org/blog/2020/02/slider-0-1-0/thumb-wd.jpg"><link rel=apple-touch-icon sizes=180x180 href=/images/favicons/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/images/favicons/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/images/favicons/favicon-16x16.png><link rel=manifest href=/images/favicons/site.webmanifest><link rel=mask-icon href=/images/favicons/safari-pinned-tab.svg><link rel="shortcut icon" href=/images/favicons/favicon.ico><meta name=msapplication-TileColor content="#da532c"><meta name=msapplication-config href=/images/favicons/browserconfig.xml><script type=text/javascript src=/js/jquery-3.5.1.min.js></script><script type=text/javascript src=/js/site.js></script><link rel=icon href=/images/favicon.ico><script type=text/javascript src=/js/clipboard.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin=anonymous></script><script defer data-domain=tidyverse.org,all.tidyverse.org src=https://plausible.io/js/plausible.js></script></head><body><div id=appTidyverseSite class="shrinkHeader alwaysShrinkHeader"><div id=main><div id=rStudioHeader><nav class=band><div class="innards bandContent"><div><a class=productName href=/>Tidyverse</a></div><div id=menu><div id=menuToggler></div><div id=menuItems><a class=menuItem href=/packages/>Packages</a>
<a class="menuItem current" href=/blog/>Blog</a>
<a class=menuItem href=/learn/>Learn</a>
<a class=menuItem href=/help/>Help</a>
<a class=menuItem href=/contribute/>Contribute</a></div></div></div></nav></div><main><div class="band padForHeader pushFooter"><div class=bandContent><div class="full splitColumns withMobileMargins"><div class=column75><h1 class=article-title>slider 0.1.0</h1><div class=article-header aria-hidden=true><div class=photo><img src=/blog/2020/02/slider-0-1-0/thumb-wd.jpg></div><div class=photoCredit>Photo by <a href=https://unsplash.com/photos/6RLa-tC7y0I>Arie Wubben</a></div></div><span class=article-date><i class="fas fa-calendar-day fa-fw"></i>&nbsp;&nbsp;2020/02/10</span><p style=margin-bottom:.5em;margin-top:.85em><i class="fas fa-tags"></i>&nbsp;
<a href=/tags/slider/>slider</a></p><p style=margin-top:.5em><i class="fas fa-user-circle fa-fw"></i>&nbsp;
Davis Vaughan</p><div class=article-content><p>I&rsquo;m thrilled to announce that the first version of
<a href=https://davisvaughan.github.io/slider/ target=_blank rel=noopener>slider</a> is now available on CRAN!</p><p>slider provides a family of general purpose sliding window functions, which can be used to compute moving averages, cumulatives sums, rolling regressions, and any other sliding operation.</p><p>This package is a combination of ideas from a variety of sources, including:</p><ul><li><p><a href=https://purrr.tidyverse.org/ target=_blank rel=noopener>purrr</a> for the overall package API</p></li><li><p><a href=https://www.postgresql.org/docs/9.1/sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS target=_blank rel=noopener>SQL&rsquo;s window functions</a> for the argument API</p></li><li><p><a href=https://github.com/tidyverts/tsibble target=_blank rel=noopener>Earo Wang&rsquo;s <code>tsibble::slide()</code></a> for the function names</p></li><li><p><a href=https://rdatatable.gitlab.io/data.table/ target=_blank rel=noopener>data.table&rsquo;s non-equi joins</a> for inspiration on how <code>slide_index()</code> should work</p></li></ul><p>Install slider with:</p><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=nf>install.packages</span><span class=p>(</span><span class=s>&#34;slider&#34;</span><span class=p>)</span>
</code></pre></div><p>This blog post summarizes the three key functions in slider: <code>slide()</code>, <code>slide_index()</code>, and <code>slide_period()</code>.</p><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=nf>library</span><span class=p>(</span><span class=n>slider</span><span class=p>)</span>
<span class=nf>library</span><span class=p>(</span><span class=n>tibble</span><span class=p>)</span>
<span class=nf>library</span><span class=p>(</span><span class=n>purrr</span><span class=p>)</span>
<span class=nf>library</span><span class=p>(</span><span class=n>lubridate</span><span class=p>,</span> <span class=n>warn.conflicts</span> <span class=o>=</span> <span class=kc>FALSE</span><span class=p>)</span>
<span class=nf>library</span><span class=p>(</span><span class=n>dplyr</span><span class=p>,</span> <span class=n>warn.conflicts</span> <span class=o>=</span> <span class=kc>FALSE</span><span class=p>)</span>
</code></pre></div><h2 id=sliding>Sliding
<a href=#sliding><svg class="anchor-symbol" aria-hidden="true" height="26" width="26" viewBox="0 0 22 22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="currentcolor"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h2><p><code>purrr::map()</code> allows you to iterate over a vector one element at a time and apply a function to each element. <code>slide()</code> takes that concept and generalizes it so that you can iterate over <em>sliding windows</em> of a vector, applying any function that you want to each window. To start exploring this idea, note that the defaults of <code>slide()</code> are essentially identical to <code>map()</code>.</p><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=c1># A vector of sales data for our business</span>
<span class=n>sales_vec</span> <span class=o>&lt;-</span> <span class=nf>c</span><span class=p>(</span><span class=m>2</span><span class=p>,</span> <span class=m>4</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>5</span><span class=p>)</span>

<span class=nf>slide</span><span class=p>(</span><span class=n>sales_vec</span><span class=p>,</span> <span class=o>~</span><span class=n>.x</span><span class=p>)</span>
<span class=c1>#&gt; [[1]]</span>
<span class=c1>#&gt; [1] 2</span>
<span class=c1>#&gt; </span>
<span class=c1>#&gt; [[2]]</span>
<span class=c1>#&gt; [1] 4</span>
<span class=c1>#&gt; </span>
<span class=c1>#&gt; [[3]]</span>
<span class=c1>#&gt; [1] 3</span>
<span class=c1>#&gt; </span>
<span class=c1>#&gt; [[4]]</span>
<span class=c1>#&gt; [1] 5</span>
</code></pre></div><p>Things get more interesting when you consider the additional arguments to <code>slide()</code>:</p><ul><li><p><code>.before</code>: How many elements <em>before</em> the current one should be included in the window?</p></li><li><p><code>.after</code>: How many elements <em>after</em> the current one should be included in the window?</p></li><li><p><code>.complete</code>: Should <code>.f</code> only be evaluated when there is enough data to make a complete window?</p></li><li><p><code>.step</code>: The number of elements to shift forward between calls to <code>.f</code>.</p></li></ul><p>By setting <code>.before = 1</code> we can construct moving windows along <code>.x</code>, adding the current element and the one before it into the window.</p><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=nf>slide</span><span class=p>(</span><span class=n>sales_vec</span><span class=p>,</span> <span class=o>~</span><span class=n>.x</span><span class=p>,</span> <span class=n>.before</span> <span class=o>=</span> <span class=m>1</span><span class=p>)</span>
<span class=c1>#&gt; [[1]]</span>
<span class=c1>#&gt; [1] 2</span>
<span class=c1>#&gt; </span>
<span class=c1>#&gt; [[2]]</span>
<span class=c1>#&gt; [1] 2 4</span>
<span class=c1>#&gt; </span>
<span class=c1>#&gt; [[3]]</span>
<span class=c1>#&gt; [1] 4 3</span>
<span class=c1>#&gt; </span>
<span class=c1>#&gt; [[4]]</span>
<span class=c1>#&gt; [1] 3 5</span>
</code></pre></div><p>Notice how in the first result our slice just has one element. This is an <em>incomplete</em> window because it isn&rsquo;t possible to look one element before the first element. By default, <code>slide()</code> computes <code>.f</code> on incomplete windows, but you can force it to only be computed on complete windows with <code>.complete</code>.</p><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=nf>slide</span><span class=p>(</span><span class=n>sales_vec</span><span class=p>,</span> <span class=o>~</span><span class=n>.x</span><span class=p>,</span> <span class=n>.before</span> <span class=o>=</span> <span class=m>1</span><span class=p>,</span> <span class=n>.complete</span> <span class=o>=</span> <span class=kc>TRUE</span><span class=p>)</span>
<span class=c1>#&gt; [[1]]</span>
<span class=c1>#&gt; NULL</span>
<span class=c1>#&gt; </span>
<span class=c1>#&gt; [[2]]</span>
<span class=c1>#&gt; [1] 2 4</span>
<span class=c1>#&gt; </span>
<span class=c1>#&gt; [[3]]</span>
<span class=c1>#&gt; [1] 4 3</span>
<span class=c1>#&gt; </span>
<span class=c1>#&gt; [[4]]</span>
<span class=c1>#&gt; [1] 3 5</span>
</code></pre></div><p>The API of slider is intentionally very similar to purrr. <code>slide()</code> always returns a list (like <code>map()</code>), and the size of the result is always the same size as the input. As you might have guessed, there are also suffixed versions available to return more specific output. Say we want to compute a 2-value moving average from our sales. We might use:</p><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=nf>slide_dbl</span><span class=p>(</span><span class=n>sales_vec</span><span class=p>,</span> <span class=n>mean</span><span class=p>,</span> <span class=n>.before</span> <span class=o>=</span> <span class=m>1</span><span class=p>)</span>
<span class=c1>#&gt; [1] 2.0 3.0 3.5 4.0</span>
</code></pre></div><p>There is also a new suffix, <code>*_vec()</code>, which attempts to automatically simplify the results using the type rules provided by
<a href=https://vctrs.r-lib.org/ target=_blank rel=noopener>vctrs</a>.</p><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=nf>slide_vec</span><span class=p>(</span><span class=n>sales_vec</span><span class=p>,</span> <span class=n>mean</span><span class=p>,</span> <span class=n>.before</span> <span class=o>=</span> <span class=m>1</span><span class=p>)</span>
<span class=c1>#&gt; [1] 2.0 3.0 3.5 4.0</span>

<span class=nf>slide_vec</span><span class=p>(</span><span class=n>sales_vec</span><span class=p>,</span> <span class=o>~</span><span class=nf>mean</span><span class=p>(</span><span class=n>.x</span><span class=p>)</span> <span class=o>&gt;</span> <span class=m>3</span><span class=p>,</span> <span class=n>.before</span> <span class=o>=</span> <span class=m>1</span><span class=p>)</span>
<span class=c1>#&gt; [1] FALSE FALSE  TRUE  TRUE</span>
</code></pre></div><p>Lastly, the one big difference between how <code>slide()</code> and <code>map()</code> iterate over vectors is how they treat data frames. To <code>map()</code>, a data frame is a vector of columns, to <code>slide()</code> it is a
<a href=https://blog.davisvaughan.com/2019/10/16/data-frames-as-vectors-of-rows/ target=_blank rel=noopener>vector of rows</a>. In a way, this makes <code>slide()</code> a generic row-wise iterator over data frames.</p><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=n>index_vec</span> <span class=o>&lt;-</span> <span class=nf>as.Date</span><span class=p>(</span><span class=s>&#34;2019-08-29&#34;</span><span class=p>)</span> <span class=o>+</span> <span class=nf>c</span><span class=p>(</span><span class=m>0</span><span class=p>,</span> <span class=m>1</span><span class=p>,</span> <span class=m>5</span><span class=p>,</span> <span class=m>6</span><span class=p>)</span>
<span class=n>wday_vec</span> <span class=o>&lt;-</span> <span class=nf>as.character</span><span class=p>(</span><span class=nf>wday</span><span class=p>(</span><span class=n>index_vec</span><span class=p>,</span> <span class=n>label</span> <span class=o>=</span> <span class=kc>TRUE</span><span class=p>))</span>

<span class=n>company</span> <span class=o>&lt;-</span> <span class=nf>tibble</span><span class=p>(</span>
  <span class=n>sales</span> <span class=o>=</span> <span class=n>sales_vec</span><span class=p>,</span>
  <span class=n>index</span> <span class=o>=</span> <span class=n>index_vec</span><span class=p>,</span>
  <span class=n>wday</span> <span class=o>=</span> <span class=n>wday_vec</span>
<span class=p>)</span>

<span class=n>company</span>
<span class=c1>#&gt; # A tibble: 4 x 3</span>
<span class=c1>#&gt;   sales index      wday </span>
<span class=c1>#&gt;   &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt;</span>
<span class=c1>#&gt; 1     2 2019-08-29 Thu  </span>
<span class=c1>#&gt; 2     4 2019-08-30 Fri  </span>
<span class=c1>#&gt; 3     3 2019-09-03 Tue  </span>
<span class=c1>#&gt; 4     5 2019-09-04 Wed</span>
</code></pre></div><p>Over columns:</p><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=nf>map</span><span class=p>(</span><span class=n>company</span><span class=p>,</span> <span class=o>~</span><span class=n>.x</span><span class=p>)</span>
<span class=c1>#&gt; $sales</span>
<span class=c1>#&gt; [1] 2 4 3 5</span>
<span class=c1>#&gt; </span>
<span class=c1>#&gt; $index</span>
<span class=c1>#&gt; [1] &#34;2019-08-29&#34; &#34;2019-08-30&#34; &#34;2019-09-03&#34; &#34;2019-09-04&#34;</span>
<span class=c1>#&gt; </span>
<span class=c1>#&gt; $wday</span>
<span class=c1>#&gt; [1] &#34;Thu&#34; &#34;Fri&#34; &#34;Tue&#34; &#34;Wed&#34;</span>
</code></pre></div><p>Over rows:</p><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=nf>slide</span><span class=p>(</span><span class=n>company</span><span class=p>,</span> <span class=o>~</span><span class=n>.x</span><span class=p>)</span>
<span class=c1>#&gt; [[1]]</span>
<span class=c1>#&gt; # A tibble: 1 x 3</span>
<span class=c1>#&gt;   sales index      wday </span>
<span class=c1>#&gt;   &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt;</span>
<span class=c1>#&gt; 1     2 2019-08-29 Thu  </span>
<span class=c1>#&gt; </span>
<span class=c1>#&gt; [[2]]</span>
<span class=c1>#&gt; # A tibble: 1 x 3</span>
<span class=c1>#&gt;   sales index      wday </span>
<span class=c1>#&gt;   &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt;</span>
<span class=c1>#&gt; 1     4 2019-08-30 Fri  </span>
<span class=c1>#&gt; </span>
<span class=c1>#&gt; [[3]]</span>
<span class=c1>#&gt; # A tibble: 1 x 3</span>
<span class=c1>#&gt;   sales index      wday </span>
<span class=c1>#&gt;   &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt;</span>
<span class=c1>#&gt; 1     3 2019-09-03 Tue  </span>
<span class=c1>#&gt; </span>
<span class=c1>#&gt; [[4]]</span>
<span class=c1>#&gt; # A tibble: 1 x 3</span>
<span class=c1>#&gt;   sales index      wday </span>
<span class=c1>#&gt;   &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt;</span>
<span class=c1>#&gt; 1     5 2019-09-04 Wed</span>
</code></pre></div><p>You can also still use the additional arguments to construct sliding windows along your data frame.</p><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=nf>slide</span><span class=p>(</span><span class=n>company</span><span class=p>,</span> <span class=o>~</span><span class=n>.x</span><span class=p>,</span> <span class=n>.before</span> <span class=o>=</span> <span class=m>2</span><span class=p>)</span>
<span class=c1>#&gt; [[1]]</span>
<span class=c1>#&gt; # A tibble: 1 x 3</span>
<span class=c1>#&gt;   sales index      wday </span>
<span class=c1>#&gt;   &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt;</span>
<span class=c1>#&gt; 1     2 2019-08-29 Thu  </span>
<span class=c1>#&gt; </span>
<span class=c1>#&gt; [[2]]</span>
<span class=c1>#&gt; # A tibble: 2 x 3</span>
<span class=c1>#&gt;   sales index      wday </span>
<span class=c1>#&gt;   &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt;</span>
<span class=c1>#&gt; 1     2 2019-08-29 Thu  </span>
<span class=c1>#&gt; 2     4 2019-08-30 Fri  </span>
<span class=c1>#&gt; </span>
<span class=c1>#&gt; [[3]]</span>
<span class=c1>#&gt; # A tibble: 3 x 3</span>
<span class=c1>#&gt;   sales index      wday </span>
<span class=c1>#&gt;   &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt;</span>
<span class=c1>#&gt; 1     2 2019-08-29 Thu  </span>
<span class=c1>#&gt; 2     4 2019-08-30 Fri  </span>
<span class=c1>#&gt; 3     3 2019-09-03 Tue  </span>
<span class=c1>#&gt; </span>
<span class=c1>#&gt; [[4]]</span>
<span class=c1>#&gt; # A tibble: 3 x 3</span>
<span class=c1>#&gt;   sales index      wday </span>
<span class=c1>#&gt;   &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt;</span>
<span class=c1>#&gt; 1     4 2019-08-30 Fri  </span>
<span class=c1>#&gt; 2     3 2019-09-03 Tue  </span>
<span class=c1>#&gt; 3     5 2019-09-04 Wed</span>
</code></pre></div><h2 id=index-sliding>Index sliding
<a href=#index-sliding><svg class="anchor-symbol" aria-hidden="true" height="26" width="26" viewBox="0 0 22 22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="currentcolor"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h2><p>Throughout R&rsquo;s history, a few of the features of <code>slide()</code> have been available in other packages. You could accomplish some of the same things with <code>zoo::rollapply()</code>, <code>tsibble::slide()</code>, and even with my original attempt at this, <code>tibbletime::rollify()</code>.</p><p>But none of these methods ever solved a problem that is incredibly common in business-oriented data analysis. What happens when you have a date index attached to when the sales happened, and you want to compute a moving average over <em>two days</em>? <code>slide()</code> doesn&rsquo;t solve this problem either, because you might have date gaps in your vector that it doesn&rsquo;t know about. To demonstrate this, let&rsquo;s assume that you are interested in computing those two day windows. To visualize them, we&rsquo;ll print out the week day that would be associated with these naive windows if we used <code>slide()</code>.</p><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=n>wday_vec</span>
<span class=c1>#&gt; [1] &#34;Thu&#34; &#34;Fri&#34; &#34;Tue&#34; &#34;Wed&#34;</span>

<span class=nf>slide</span><span class=p>(</span><span class=n>wday_vec</span><span class=p>,</span> <span class=o>~</span><span class=n>.x</span><span class=p>,</span> <span class=n>.before</span> <span class=o>=</span> <span class=m>1</span><span class=p>)</span>
<span class=c1>#&gt; [[1]]</span>
<span class=c1>#&gt; [1] &#34;Thu&#34;</span>
<span class=c1>#&gt; </span>
<span class=c1>#&gt; [[2]]</span>
<span class=c1>#&gt; [1] &#34;Thu&#34; &#34;Fri&#34;</span>
<span class=c1>#&gt; </span>
<span class=c1>#&gt; [[3]]</span>
<span class=c1>#&gt; [1] &#34;Fri&#34; &#34;Tue&#34;</span>
<span class=c1>#&gt; </span>
<span class=c1>#&gt; [[4]]</span>
<span class=c1>#&gt; [1] &#34;Tue&#34; &#34;Wed&#34;</span>
</code></pre></div><p>Notice the third window! We started on Tuesday, which means the window should only include <code>[Mon, Tue]</code>, but Friday is also included here. This happens because <code>slide()</code> looks back a number of <em>values</em>, and knows nothing about how to compute this <code>[Mon, Tue]</code> <em>range</em> to slide between. This differentiation between values and ranges comes from SQL, and is further explained in a bit more detail by
<a href="https://www.vertica.com/docs/9.2.x/HTML/Content/Authoring/SQLReferenceManual/Functions/Analytic/window_frame_clause.htm?origin_team=T02V9CHFH#ROWSversusRANGE" target=_blank rel=noopener>Vertica&rsquo;s window function documentation</a>.</p><p>To solve this specific problem of sliding with respect to an index, we&rsquo;ll need a new function, <code>slide_index()</code>. It&rsquo;s similar to <code>slide()</code>, and has all of the same suffixed versions, but allows you to pass in a secondary index to slide relative to. Ranges to slide between are computed as <code>.i - .before</code> and <code>.i + .after</code>, meaning that you can use more interesting objects for <code>.before</code>, like <code>lubridate::days()</code>! It just has to implement <code>-</code> and <code>+</code> methods when combined with your index.</p><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=n>wday_vec</span>
<span class=c1>#&gt; [1] &#34;Thu&#34; &#34;Fri&#34; &#34;Tue&#34; &#34;Wed&#34;</span>
<span class=n>index_vec</span>
<span class=c1>#&gt; [1] &#34;2019-08-29&#34; &#34;2019-08-30&#34; &#34;2019-09-03&#34; &#34;2019-09-04&#34;</span>

<span class=nf>slide_index</span><span class=p>(</span><span class=n>.x</span> <span class=o>=</span> <span class=n>wday_vec</span><span class=p>,</span> <span class=n>.i</span> <span class=o>=</span> <span class=n>index_vec</span><span class=p>,</span> <span class=o>~</span><span class=n>.x</span><span class=p>,</span> <span class=n>.before</span> <span class=o>=</span> <span class=nf>days</span><span class=p>(</span><span class=m>1</span><span class=p>))</span>
<span class=c1>#&gt; [[1]]</span>
<span class=c1>#&gt; [1] &#34;Thu&#34;</span>
<span class=c1>#&gt; </span>
<span class=c1>#&gt; [[2]]</span>
<span class=c1>#&gt; [1] &#34;Thu&#34; &#34;Fri&#34;</span>
<span class=c1>#&gt; </span>
<span class=c1>#&gt; [[3]]</span>
<span class=c1>#&gt; [1] &#34;Tue&#34;</span>
<span class=c1>#&gt; </span>
<span class=c1>#&gt; [[4]]</span>
<span class=c1>#&gt; [1] &#34;Tue&#34; &#34;Wed&#34;</span>
</code></pre></div><p>This correctly buckets Tuesday in its own group, since there is no data point for the Monday before it. We can compare the difference between a two-value vs a two-day moving average like so:</p><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=n>company</span> <span class=o>%&gt;%</span>
  <span class=nf>mutate</span><span class=p>(</span>
    <span class=n>two_value</span> <span class=o>=</span> <span class=nf>slide_dbl</span><span class=p>(</span><span class=n>sales</span><span class=p>,</span> <span class=n>mean</span><span class=p>,</span> <span class=n>.before</span> <span class=o>=</span> <span class=m>1</span><span class=p>),</span>
    <span class=n>two_day</span> <span class=o>=</span> <span class=nf>slide_index_dbl</span><span class=p>(</span><span class=n>sales</span><span class=p>,</span> <span class=n>index</span><span class=p>,</span> <span class=n>mean</span><span class=p>,</span> <span class=n>.before</span> <span class=o>=</span> <span class=nf>days</span><span class=p>(</span><span class=m>1</span><span class=p>)),</span>
  <span class=p>)</span>
<span class=c1>#&gt; # A tibble: 4 x 5</span>
<span class=c1>#&gt;   sales index      wday  two_value two_day</span>
<span class=c1>#&gt;   &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt;     &lt;dbl&gt;   &lt;dbl&gt;</span>
<span class=c1>#&gt; 1     2 2019-08-29 Thu         2         2</span>
<span class=c1>#&gt; 2     4 2019-08-30 Fri         3         3</span>
<span class=c1>#&gt; 3     3 2019-09-03 Tue         3.5       3</span>
<span class=c1>#&gt; 4     5 2019-09-04 Wed         4         4</span>
</code></pre></div><h2 id=period-sliding>Period sliding
<a href=#period-sliding><svg class="anchor-symbol" aria-hidden="true" height="26" width="26" viewBox="0 0 22 22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="currentcolor"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h2><p>While <code>slide()</code> and <code>slide_index()</code> are great because they are size-stable, sometimes you&rsquo;ll want to take data that has a daily index, break it into monthly chunks, and return results at the monthly level. This implies returning an output that has a different size from your input. To power these ideas, you can use <code>slide_period()</code>, which takes an index and a period to chunk by, and then iterates over <code>.x</code> relative to those period chunks.</p><p>Say we want to take <code>big_company</code> below, break it into monthly chunks, and compute and return just the monthly totals.</p><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=n>big_index_vec</span> <span class=o>&lt;-</span> <span class=nf>c</span><span class=p>(</span>
  <span class=nf>as.Date</span><span class=p>(</span><span class=s>&#34;2019-08-30&#34;</span><span class=p>)</span> <span class=o>+</span> <span class=m>0</span><span class=o>:</span><span class=m>4</span><span class=p>,</span>
  <span class=nf>as.Date</span><span class=p>(</span><span class=s>&#34;2019-11-30&#34;</span><span class=p>)</span> <span class=o>+</span> <span class=m>0</span><span class=o>:</span><span class=m>4</span>
<span class=p>)</span>

<span class=n>big_sales_vec</span> <span class=o>&lt;-</span> <span class=nf>c</span><span class=p>(</span><span class=m>2</span><span class=p>,</span> <span class=m>4</span><span class=p>,</span> <span class=m>6</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>8</span><span class=p>,</span> <span class=m>10</span><span class=p>,</span> <span class=m>9</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>5</span><span class=p>,</span> <span class=m>2</span><span class=p>)</span>

<span class=n>big_company</span> <span class=o>&lt;-</span> <span class=nf>tibble</span><span class=p>(</span>
  <span class=n>sales</span> <span class=o>=</span> <span class=n>big_sales_vec</span><span class=p>,</span>
  <span class=n>index</span> <span class=o>=</span> <span class=n>big_index_vec</span>
<span class=p>)</span>

<span class=n>big_company</span>
<span class=c1>#&gt; # A tibble: 10 x 2</span>
<span class=c1>#&gt;    sales index     </span>
<span class=c1>#&gt;    &lt;dbl&gt; &lt;date&gt;    </span>
<span class=c1>#&gt;  1     2 2019-08-30</span>
<span class=c1>#&gt;  2     4 2019-08-31</span>
<span class=c1>#&gt;  3     6 2019-09-01</span>
<span class=c1>#&gt;  4     2 2019-09-02</span>
<span class=c1>#&gt;  5     8 2019-09-03</span>
<span class=c1>#&gt;  6    10 2019-11-30</span>
<span class=c1>#&gt;  7     9 2019-12-01</span>
<span class=c1>#&gt;  8     3 2019-12-02</span>
<span class=c1>#&gt;  9     5 2019-12-03</span>
<span class=c1>#&gt; 10     2 2019-12-04</span>
</code></pre></div><p><code>slide_period()</code> allows you to iterate over your data frame in these monthly chunks, applying whatever function you want to each one.</p><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=nf>slide_period</span><span class=p>(</span><span class=n>big_company</span><span class=p>,</span> <span class=n>big_company</span><span class=o>$</span><span class=n>index</span><span class=p>,</span> <span class=s>&#34;month&#34;</span><span class=p>,</span> <span class=o>~</span><span class=n>.x</span><span class=p>)</span>
<span class=c1>#&gt; [[1]]</span>
<span class=c1>#&gt; # A tibble: 2 x 2</span>
<span class=c1>#&gt;   sales index     </span>
<span class=c1>#&gt;   &lt;dbl&gt; &lt;date&gt;    </span>
<span class=c1>#&gt; 1     2 2019-08-30</span>
<span class=c1>#&gt; 2     4 2019-08-31</span>
<span class=c1>#&gt; </span>
<span class=c1>#&gt; [[2]]</span>
<span class=c1>#&gt; # A tibble: 3 x 2</span>
<span class=c1>#&gt;   sales index     </span>
<span class=c1>#&gt;   &lt;dbl&gt; &lt;date&gt;    </span>
<span class=c1>#&gt; 1     6 2019-09-01</span>
<span class=c1>#&gt; 2     2 2019-09-02</span>
<span class=c1>#&gt; 3     8 2019-09-03</span>
<span class=c1>#&gt; </span>
<span class=c1>#&gt; [[3]]</span>
<span class=c1>#&gt; # A tibble: 1 x 2</span>
<span class=c1>#&gt;   sales index     </span>
<span class=c1>#&gt;   &lt;dbl&gt; &lt;date&gt;    </span>
<span class=c1>#&gt; 1    10 2019-11-30</span>
<span class=c1>#&gt; </span>
<span class=c1>#&gt; [[4]]</span>
<span class=c1>#&gt; # A tibble: 4 x 2</span>
<span class=c1>#&gt;   sales index     </span>
<span class=c1>#&gt;   &lt;dbl&gt; &lt;date&gt;    </span>
<span class=c1>#&gt; 1     9 2019-12-01</span>
<span class=c1>#&gt; 2     3 2019-12-02</span>
<span class=c1>#&gt; 3     5 2019-12-03</span>
<span class=c1>#&gt; 4     2 2019-12-04</span>
</code></pre></div><p>I find it easiest to wrap up what you want to do into a function, and then apply that to each slice.</p><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=n>monthly_summary</span> <span class=o>&lt;-</span> <span class=nf>function</span><span class=p>(</span><span class=n>data</span><span class=p>)</span> <span class=p>{</span>
  <span class=nf>summarise</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>start</span> <span class=o>=</span> <span class=nf>min</span><span class=p>(</span><span class=n>index</span><span class=p>),</span> <span class=n>end</span> <span class=o>=</span> <span class=nf>max</span><span class=p>(</span><span class=n>index</span><span class=p>),</span> <span class=n>total_sales</span> <span class=o>=</span> <span class=nf>sum</span><span class=p>(</span><span class=n>sales</span><span class=p>))</span>
<span class=p>}</span>

<span class=nf>slide_period_dfr</span><span class=p>(</span>
  <span class=n>big_company</span><span class=p>,</span>
  <span class=n>big_company</span><span class=o>$</span><span class=n>index</span><span class=p>,</span>
  <span class=s>&#34;month&#34;</span><span class=p>,</span>
  <span class=n>monthly_summary</span>
<span class=p>)</span>
<span class=c1>#&gt; # A tibble: 4 x 3</span>
<span class=c1>#&gt;   start      end        total_sales</span>
<span class=c1>#&gt;   &lt;date&gt;     &lt;date&gt;           &lt;dbl&gt;</span>
<span class=c1>#&gt; 1 2019-08-30 2019-08-31           6</span>
<span class=c1>#&gt; 2 2019-09-01 2019-09-03          16</span>
<span class=c1>#&gt; 3 2019-11-30 2019-11-30          10</span>
<span class=c1>#&gt; 4 2019-12-01 2019-12-04          19</span>
</code></pre></div><p>Now, you might recognize that you can do this with dplyr:</p><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=n>big_company</span> <span class=o>%&gt;%</span>
  <span class=nf>mutate</span><span class=p>(</span><span class=n>monthly</span> <span class=o>=</span> <span class=nf>floor_date</span><span class=p>(</span><span class=n>index</span><span class=p>,</span> <span class=s>&#34;month&#34;</span><span class=p>))</span> <span class=o>%&gt;%</span>
  <span class=nf>group_by</span><span class=p>(</span><span class=n>monthly</span><span class=p>)</span> <span class=o>%&gt;%</span>
  <span class=nf>summarise</span><span class=p>(</span><span class=n>sales</span> <span class=o>=</span> <span class=nf>sum</span><span class=p>(</span><span class=n>sales</span><span class=p>))</span>
<span class=c1>#&gt; # A tibble: 4 x 2</span>
<span class=c1>#&gt;   monthly    sales</span>
<span class=c1>#&gt;   &lt;date&gt;     &lt;dbl&gt;</span>
<span class=c1>#&gt; 1 2019-08-01     6</span>
<span class=c1>#&gt; 2 2019-09-01    16</span>
<span class=c1>#&gt; 3 2019-11-01    10</span>
<span class=c1>#&gt; 4 2019-12-01    19</span>
</code></pre></div><p>But what you can&rsquo;t easily do is slide over multiple monthly chunks at once, effectively creating a rolling monthly total, from daily data. With <code>slide_period()</code>, <code>.before</code> works at the period level, so you get to control how many monthly periods are included in your sliding window. Notice how the start dates below go back into the previous month (but only if there was data for it).</p><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=nf>slide_period_dfr</span><span class=p>(</span>
  <span class=n>big_company</span><span class=p>,</span>
  <span class=n>big_company</span><span class=o>$</span><span class=n>index</span><span class=p>,</span>
  <span class=s>&#34;month&#34;</span><span class=p>,</span>
  <span class=n>monthly_summary</span><span class=p>,</span>
  <span class=n>.before</span> <span class=o>=</span> <span class=m>1</span>
<span class=p>)</span>
<span class=c1>#&gt; # A tibble: 4 x 3</span>
<span class=c1>#&gt;   start      end        total_sales</span>
<span class=c1>#&gt;   &lt;date&gt;     &lt;date&gt;           &lt;dbl&gt;</span>
<span class=c1>#&gt; 1 2019-08-30 2019-08-31           6</span>
<span class=c1>#&gt; 2 2019-08-30 2019-09-03          22</span>
<span class=c1>#&gt; 3 2019-11-30 2019-11-30          10</span>
<span class=c1>#&gt; 4 2019-11-30 2019-12-04          29</span>
</code></pre></div><h2 id=acknowledgements>Acknowledgements
<a href=#acknowledgements><svg class="anchor-symbol" aria-hidden="true" height="26" width="26" viewBox="0 0 22 22" xmlns="http://www.w3.org/2000/svg"><path d="M0 0h24v24H0z" fill="currentcolor"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76.0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71.0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71.0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76.0 5-2.24 5-5s-2.24-5-5-5z"/></svg></a></h2><p>A big thanks to some of the early adopters of slider!</p><p><a href=https://github.com/AlanFeder target=_blank rel=noopener>@AlanFeder</a>,
<a href=https://github.com/AlunHewinson target=_blank rel=noopener>@AlunHewinson</a>,
<a href=https://github.com/echasnovski target=_blank rel=noopener>@echasnovski</a>,
<a href=https://github.com/mik3y64 target=_blank rel=noopener>@mik3y64</a>,
<a href=https://github.com/perlatex target=_blank rel=noopener>@perlatex</a>, and
<a href=https://github.com/RobertMyles target=_blank rel=noopener>@RobertMyles</a>.</p></div></div><div class=column25><div class="section hideOnMobile"><div class=sectionTitle>Contents</div><nav id=TableOfContents><ul><li><a href=#sliding>Sliding</a></li><li><a href=#index-sliding>Index sliding</a></li><li><a href=#period-sliding>Period sliding</a></li><li><a href=#acknowledgements>Acknowledgements</a></li></ul></nav></div><div class=section></div></div></div></div></div><div id=rStudioFooter class=band><div class=bandContent><div id=copyright>The tidyverse is proudly supported by <a class=rstudioLogo href=https://posit.co/ aria-label="Posit Homepage"></a></div><div id=logos><a href=https://www.tidyverse.org/google_privacy_policy>Privacy policy</a>
<a href=https://github.com/tidyverse class="footerLogo gitHub" aria-label="Tidyverse GitHub organization"></a><a href=https://twitter.com/hashtag/rstats class="footerLogo twitter" aria-label="rstats hashtag on twitter.com"></a></div></div></div></div></div><script src=/js/math-code.js></script><script type=text/x-mathjax-config>
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
  }
});
</script><script async src="//cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script type=application/javascript>var dnt=(navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack);var doNotTrack=(dnt=="1"||dnt=="yes");if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');if(window.sessionStorage){var GA_SESSION_STORAGE_KEY='ga:clientId';ga('create','UA-115082821-1',{'storage':'none','clientId':sessionStorage.getItem(GA_SESSION_STORAGE_KEY)});ga(function(tracker){sessionStorage.setItem(GA_SESSION_STORAGE_KEY,tracker.get('clientId'));});}
ga('set','anonymizeIp',true);ga('send','pageview');}</script></body></html></div></div></body></html>