<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>lubridate | Tidyverse</title><link>https://www.tidyverse.org/tags/lubridate/</link><atom:link href="https://www.tidyverse.org/tags/lubridate/index.xml" rel="self" type="application/rss+xml"/><description>lubridate</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 01 Nov 2017 00:00:00 +0000</lastBuildDate><item><title>lubridate 1.7.0</title><link>https://www.tidyverse.org/blog/2017/11/lubridate-1.7.0/</link><pubDate>Wed, 01 Nov 2017 00:00:00 +0000</pubDate><guid>https://www.tidyverse.org/blog/2017/11/lubridate-1.7.0/</guid><description>
&lt;p>We are pleased to announce that &lt;a href="https://cran.r-project.org/web/packages/lubridate/index.html">lubridate 1.7.0&lt;/a> is now on CRAN! For a complete set of changes please see the release &lt;a href="https://github.com/tidyverse/lubridate/releases/tag/v1.7.0">NEWS&lt;/a>.&lt;/p>
&lt;p>Lubridate is a package that makes working with date-time and time-span objects easier. It provides fast and user friendly parsing of date-time strings, extraction and updating of components of a date-time objects (years, months, days etc.) and algebraic manipulation on date-time and time-span objects.&lt;/p>
&lt;p>Here is a brief walk-through of the prominent new features in 1.7.0.&lt;/p>
&lt;div id="built-in-cctz-and-much-faster-update-and-force_tz" class="section level2">
&lt;h2>Built-in CCTZ and much faster &lt;code>update&lt;/code> and &lt;code>force_tz&lt;/code>&lt;/h2>
&lt;p>From this version lubridate relies on google’s &lt;a href="https://github.com/google/cctz">CCTZ&lt;/a> library for the date-time updates and time-zone manipulation. This means that &lt;code>force_tz&lt;/code>, &lt;code>update&lt;/code>, &lt;code>round&lt;/code>ing and a range of arithmetic operations on timespans are now considerably faster.&lt;/p>
&lt;/div>
&lt;div id="vectorized-time-zone-manipulation" class="section level2">
&lt;h2>Vectorized time-zone manipulation&lt;/h2>
&lt;p>Often date-time data comes with heterogeneous time-zones. For example, you might have a character vector of date-times and a separate vector of time-zones. In such cases you can parse your date-time vector in one time zone (&lt;code>UTC&lt;/code>) and then “enforce” the heterogeneous time-zones with &lt;code>force_tzs&lt;/code>.&lt;/p>
&lt;pre class="r">&lt;code>x &amp;lt;- ymd_hms(c(&amp;quot;2009-08-01 00:00:00&amp;quot;, &amp;quot;2009-08-01 00:00:00&amp;quot;))
tzs &amp;lt;- c(&amp;quot;America/New_York&amp;quot;, &amp;quot;Europe/Amsterdam&amp;quot;)
force_tzs(x, tzones = tzs)
##=&amp;gt; [1] &amp;quot;2009-08-01 04:00:00 UTC&amp;quot; &amp;quot;2009-07-31 22:00:00 UTC&amp;quot;
force_tzs(x, tzones = tzs, tzone_out = &amp;quot;America/New_York&amp;quot;)
##=&amp;gt; [1] &amp;quot;2009-08-01 00:00:00 EDT&amp;quot; &amp;quot;2009-07-31 18:00:00 EDT&amp;quot;&lt;/code>&lt;/pre>
&lt;p>Note that first &lt;code>force_tzs&lt;/code> call produced a vector of instants in UTC time-zone, for the second call we specified the desired time-zone of the output vector with the &lt;code>tzone_out&lt;/code> argument. This is needed as R’s date-time vectors cannot represent heterogeneous time-zones. For the same reason, the counterpart of &lt;code>with_tz&lt;/code>, &lt;code>with_tzs&lt;/code>, does not exist. Instead, &lt;code>local_time&lt;/code> should cover the &lt;code>with_tzs&lt;/code> use case in most situations.&lt;/p>
&lt;p>New &lt;code>local_time&lt;/code> function retrieves day clock time of the input vector in the specified time zones. It returns a &lt;code>difftime&lt;/code> object and it is vectorized over both date-time and time-zone arguments:&lt;/p>
&lt;pre class="r">&lt;code>x &amp;lt;- ymd_hms(c(&amp;quot;2009-08-01 01:02:03&amp;quot;, &amp;quot;2009-08-01 10:20:30&amp;quot;))
local_time(x, units = &amp;quot;hours&amp;quot;)
##=&amp;gt; Time differences in hours
##=&amp;gt; [1] 1.034167 10.341667
x &amp;lt;- ymd_hms(c(&amp;quot;2009-08-01 00:00:00&amp;quot;, &amp;quot;2009-08-01 00:00:00&amp;quot;))
tzs &amp;lt;- c(&amp;quot;America/New_York&amp;quot;, &amp;quot;Europe/Amsterdam&amp;quot;)
local_time(x, tzs, units = &amp;quot;hours&amp;quot;)
##=&amp;gt; Time differences in hours
##=&amp;gt; [1] 20 2&lt;/code>&lt;/pre>
&lt;/div>
&lt;div id="new-cutoff_2000-parameter-in-parsing-functions" class="section level2">
&lt;h2>New &lt;code>cutoff_2000&lt;/code> parameter in parsing functions&lt;/h2>
&lt;p>Lower level lubridate parser functions (&lt;code>parse_datetime2&lt;/code>,&lt;code>fast_strptime&lt;/code>) now accept &lt;code>cutoff_2000&lt;/code> parameter to determine when the parsing of &lt;code>yy&lt;/code> format should output 19th or 20th century.&lt;/p>
&lt;pre class="r">&lt;code>x &amp;lt;- c(&amp;quot;50-01-01&amp;quot;, &amp;quot;70-01-01&amp;quot;)
parse_date_time2(x, &amp;quot;ymd&amp;quot;)
##=&amp;gt; [1] &amp;quot;2050-01-01 UTC&amp;quot; &amp;quot;1970-01-01 UTC&amp;quot;
parse_date_time2(x, &amp;quot;ymd&amp;quot;, cutoff_2000 = 30)
##=&amp;gt; [1] &amp;quot;1950-01-01 UTC&amp;quot; &amp;quot;1970-01-01 UTC&amp;quot;&lt;/code>&lt;/pre>
&lt;p>By default &lt;code>cutoff_2000&lt;/code> is 68 to comply with R’s &lt;code>strptime&lt;/code> function.&lt;/p>
&lt;p>This feature was not propagated to higher level parsing function because base &lt;code>strptime&lt;/code>, on which those occasionally rely, doesn’t support this option.&lt;/p>
&lt;/div>
&lt;div id="functions-wday-and-month-are-now-localized" class="section level2">
&lt;h2>Functions &lt;code>wday&lt;/code> and &lt;code>month&lt;/code> are now localized&lt;/h2>
&lt;p>When &lt;code>label=TRUE&lt;/code> &lt;code>wday&lt;/code> and &lt;code>month&lt;/code> extractors return localized strings:&lt;/p>
&lt;pre class="r">&lt;code>Sys.setlocale(locale = &amp;quot;zh_CN.utf8&amp;quot;)
##=&amp;gt; [1] &amp;quot;LC_CTYPE=zh_CN.utf8;LC_NUMERIC=C;LC_TIME=zh_CN.utf8;LC_COLLATE=zh_CN.utf8;LC_MONETARY=zh_CN.utf8;LC_MESSAGES=C;LC_PAPER=en_GB.UTF-8;LC_NAME=C;LC_ADDRESS=C;LC_TELEPHONE=C;LC_MEASUREMENT=en_GB.UTF-8;LC_IDENTIFICATION=C&amp;quot;
wday(now(), label = TRUE)
##=&amp;gt; [1] 三
##=&amp;gt; Levels: 日 &amp;lt; 一 &amp;lt; 二 &amp;lt; 三 &amp;lt; 四 &amp;lt; 五 &amp;lt; 六
month(now(), label = TRUE)
##=&amp;gt; [1] 11月
##=&amp;gt; 12 Levels: 1月 &amp;lt; 2月 &amp;lt; 3月 &amp;lt; 4月 &amp;lt; 5月 &amp;lt; 6月 &amp;lt; 7月 &amp;lt; 8月 &amp;lt; ... &amp;lt; 12月&lt;/code>&lt;/pre>
&lt;p>Please note that for this reason using labels for comparison is not recommended. You should use numeric output instead. Otherwise your code might not work on other computers.&lt;/p>
&lt;/div>
&lt;div id="several-functions-gained-the-week_start-parameter" class="section level2">
&lt;h2>Several functions gained the &lt;code>week_start&lt;/code> parameter&lt;/h2>
&lt;p>Functions for which depend on the week-start conventions (&lt;code>wday&lt;/code>, &lt;code>wday&amp;lt;-&lt;/code>, &lt;code>floor_date&lt;/code>, &lt;code>ceiling_date&lt;/code> and &lt;code>round_date&lt;/code>) now accept &lt;code>week_start&lt;/code> argument which defaults to &lt;code>getOption(&amp;quot;lubridate.week.start&amp;quot;, 7)&lt;/code>.&lt;/p>
&lt;pre class="r">&lt;code>x &amp;lt;- today()
wday(x, label = TRUE, abbr = FALSE)
##=&amp;gt; [1] 星期三
##=&amp;gt; 7 Levels: 星期日 &amp;lt; 星期一 &amp;lt; 星期二 &amp;lt; 星期三 &amp;lt; 星期四 &amp;lt; ... &amp;lt; 星期六
wday(x)
##=&amp;gt; [1] 4
wday(x, week_start = 2)
##=&amp;gt; [1] 2&lt;/code>&lt;/pre>
&lt;/div>
&lt;div id="rounding-to-fraction-of-a-second" class="section level2">
&lt;h2>Rounding to fraction of a second&lt;/h2>
&lt;p>R’s date-time format (POSIXct) is accurate up to microseconds, thus it makes sense to round to fractions of a second. Unfortunately R currently prints fractional seconds incorrectly which can lead to confusion:&lt;/p>
&lt;pre class="r">&lt;code>## print fractional seconds
options(digits.secs=6, digits = 13)
x &amp;lt;- ymd_hms(&amp;quot;2009-08-03 12:01:59.031&amp;quot;)
rx &amp;lt;- round_date(x, &amp;quot;.01sec&amp;quot;)
cx &amp;lt;- ceiling_date(x, &amp;quot;.01sec&amp;quot;)
c(rx, cx)
##=&amp;gt; [1] &amp;quot;2009-08-03 14:01:59.02 CEST&amp;quot; &amp;quot;2009-08-03 14:01:59.03 CEST&amp;quot;
as.double(c(rx, cx))
##=&amp;gt; [1] 1249300919.03 1249300919.04&lt;/code>&lt;/pre>
&lt;p>So, fractional rounding and ceiling work, but don’t be taken aback by incorrect printing;)&lt;/p>
&lt;/div>
&lt;div id="new-epiweek-and-epiyear-functions" class="section level2">
&lt;h2>New &lt;code>epiweek&lt;/code> and &lt;code>epiyear&lt;/code> functions&lt;/h2>
&lt;p>New functions &lt;code>epiyear&lt;/code> and &lt;code>epiweek&lt;/code> are the US CDC version of epidemiological weeks and years. They follow same rules as &lt;code>isoweek&lt;/code> and &lt;code>isoyear&lt;/code> but with the week starting on Sunday. In other parts of the world the convention is to start epidemiological weeks on Monday, which is then the same as for &lt;code>isoweek&lt;/code> and &lt;code>isoyear&lt;/code>.&lt;/p>
&lt;/div></description></item></channel></rss>